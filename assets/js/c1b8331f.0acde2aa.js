"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([[984166],{15680:(e,a,n)=>{n.d(a,{xA:()=>d,yg:()=>y});var t=n(296540);function s(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function r(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function l(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?r(Object(n),!0).forEach((function(a){s(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function i(e,a){if(null==e)return{};var n,t,s=function(e,a){if(null==e)return{};var n,t,s={},r=Object.keys(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||(s[n]=e[n]);return s}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var o=t.createContext({}),g=function(e){var a=t.useContext(o),n=a;return e&&(n="function"==typeof e?e(a):l(l({},a),e)),n},d=function(e){var a=g(e.components);return t.createElement(o.Provider,{value:a},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},p=t.forwardRef((function(e,a){var n=e.components,s=e.mdxType,r=e.originalType,o=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=g(n),p=s,y=u["".concat(o,".").concat(p)]||u[p]||c[p]||r;return n?t.createElement(y,l(l({ref:a},d),{},{components:n})):t.createElement(y,l({ref:a},d))}));function y(e,a){var n=arguments,s=a&&a.mdxType;if("string"==typeof e||s){var r=n.length,l=new Array(r);l[0]=p;var i={};for(var o in a)hasOwnProperty.call(a,o)&&(i[o]=a[o]);i.originalType=e,i[u]="string"==typeof e?e:s,l[1]=i;for(var g=2;g<r;g++)l[g]=n[g];return t.createElement.apply(null,l)}return t.createElement.apply(null,n)}p.displayName="MDXCreateElement"},551925:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>i,toc:()=>g});var t=n(58168),s=(n(296540),n(15680));const r={title:"Multi-Dimensional Analytics",language:"en"},l=void 0,i={unversionedId:"query-data/multi-dimensional-analytics",id:"version-3.0/query-data/multi-dimensional-analytics",title:"Multi-Dimensional Analytics",description:"\x3c!--",source:"@site/versioned_docs/version-3.0/query-data/multi-dimensional-analytics.md",sourceDirName:"query-data",slug:"/query-data/multi-dimensional-analytics",permalink:"/docs/3.0/query-data/multi-dimensional-analytics",draft:!1,tags:[],version:"3.0",frontMatter:{title:"Multi-Dimensional Analytics",language:"en"},sidebar:"docs",previous:{title:"Subquery",permalink:"/docs/3.0/query-data/subquery"},next:{title:"Window Function",permalink:"/docs/3.0/query-data/window-function"}},o={},g=[{value:"ROLLUP",id:"rollup",level:2},{value:"Use Case",id:"use-case",level:3},{value:"Syntax and Example",id:"syntax-and-example",level:3},{value:"CUBE",id:"cube",level:2},{value:"Use Case",id:"use-case-1",level:3},{value:"Syntax and Example",id:"syntax-and-example-1",level:3},{value:"GROUPING FUNCTION",id:"grouping-function",level:2},{value:"GROUPING",id:"grouping",level:3},{value:"GROUPING_ID",id:"grouping_id",level:3},{value:"GROUPING SETS",id:"grouping-sets",level:3},{value:"Design Document",id:"design-document",level:2}],d={toc:g},u="wrapper";function c(e){let{components:a,...n}=e;return(0,s.yg)(u,(0,t.A)({},d,n,{components:a,mdxType:"MDXLayout"}),(0,s.yg)("p",null,"In a database, ROLLUP, CUBE, and GROUPING SETS are advanced SQL statements used for multidimensional data aggregation. These features significantly enhance the capabilities of the GROUP BY clause, enabling users to obtain multiple levels of summary results in a single query, which is semantically equivalent to using UNION ALL to connect multiple aggregation statements."),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("p",{parentName:"li"},(0,s.yg)("strong",{parentName:"p"},"ROLLUP"),": ROLLUP is an operation used to generate hierarchical summaries. It aggregates data according to the specified column order, gradually summarizing from the finest granularity to the highest level. For example, in sales data, ROLLUP can be used to summarize by region and time, providing sales for each region per month, total sales for each region, and overall total sales. ROLLUP is suitable for scenarios requiring step-by-step summaries.")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("p",{parentName:"li"},(0,s.yg)("strong",{parentName:"p"},"CUBE"),": CUBE is a more powerful aggregation operation that generates all possible summary combinations. Unlike ROLLUP, CUBE calculates subsets for all dimensions. For instance, for sales data aggregated by product and region, CUBE will compute sales for each product in each region, total sales for each product, total sales for each region, and overall total sales. CUBE is applicable to scenarios requiring comprehensive multidimensional analysis, such as business analysis and market research.")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("p",{parentName:"li"},(0,s.yg)("strong",{parentName:"p"},"GROUPING SETS"),": GROUPING SETS offer flexibility in aggregating specific grouping sets. It allows users to specify a set of column combinations for independent aggregation, rather than generating all possible combinations as in ROLLUP and CUBE. For example, one can define summaries for specific combinations of region and time without needing all combinations of each dimension. GROUPING SETS are suitable for scenarios requiring customized summaries, providing flexible aggregation control."))),(0,s.yg)("p",null,"ROLLUP, CUBE, and GROUPING SETS provide powerful multidimensional data summary functions, catering to various data analysis and reporting needs, and making complex aggregation calculations simpler and more efficient. The following sections will detail the usage scenarios, syntax, and examples of these features."),(0,s.yg)("h2",{id:"rollup"},"ROLLUP"),(0,s.yg)("h3",{id:"use-case"},"Use Case"),(0,s.yg)("p",null,"ROLLUP is particularly useful for summarizing data along hierarchical dimensions such as time, geography, and category. For instance, queries can specify ",(0,s.yg)("inlineCode",{parentName:"p"},"ROLLUP(year, month, day)")," or ",(0,s.yg)("inlineCode",{parentName:"p"},"(country, Province, city)"),"."),(0,s.yg)("h3",{id:"syntax-and-example"},"Syntax and Example"),(0,s.yg)("p",null,"The syntax for ROLLUP is as follows:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-sql"},"SELECT \u2026 GROUP BY ROLLUP(grouping_column_reference_list)\n")),(0,s.yg)("p",null,"Here's an example query that analyzes sales sums by year and month:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-sql"},"SELECT  \n        YEAR(d_date),  \n        MONTH(d_date),  \n        SUM(ss_net_paid) AS total_sum  \nFROM  \n        store_sales,  \n        date_dim d1  \nWHERE  \n        d1.d_date_sk = ss_sold_date_sk  \n        AND YEAR(d_date) IN (2001, 2002)  \n        AND MONTH(d_date) IN (1, 2, 3)  \nGROUP BY  \n        ROLLUP(YEAR(d_date), MONTH(d_date))  \nORDER BY  \n        YEAR(d_date), MONTH(d_date);\n")),(0,s.yg)("p",null,"This query summarizes data by time, calculating subtotals for sales by year, sales by month within each year, and the grand total of sales. The query result is as follows:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-sql"},"+--------------+---------------+-------------+  \n| YEAR(d_date) | MONTH(d_date) | total_sum   |  \n+--------------+---------------+-------------+  \n|         NULL |          NULL | 54262669.17 |  \n|         2001 |          NULL | 26640320.46 |  \n|         2001 |             1 |  9982165.83 |  \n|         2001 |             2 |  8454915.34 |  \n|         2001 |             3 |  8203239.29 |  \n|         2002 |          NULL | 27622348.71 |  \n|         2002 |             1 | 11260654.35 |  \n|         2002 |             2 |  7722750.61 |  \n|         2002 |             3 |  8638943.75 |  \n+--------------+---------------+-------------+  \n9 rows in set (0.08 sec)\n")),(0,s.yg)("h2",{id:"cube"},"CUBE"),(0,s.yg)("h3",{id:"use-case-1"},"Use Case"),(0,s.yg)("p",null,'CUBE is best suited for queries involving columns from multiple independent dimensions, rather than columns representing different levels of a single dimension. For example, a common usage scenario is summarizing all combinations of month, region, and product. These are three independent dimensions, and it is common to analyze all possible subtotal combinations. By contrast, cross-tabulating all possible combinations of year, month, and day would include several unnecessary values due to the natural hierarchy in the time dimension. In most analyses, subtotals like profits calculated by month and day are unnecessary. Relatively few users need to ask, "What is the total sales for the 16th of each month throughout the year?"'),(0,s.yg)("h3",{id:"syntax-and-example-1"},"Syntax and Example"),(0,s.yg)("p",null,"The syntax for CUBE is as follows:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-sql"},"SELECT \u2026 GROUP BY CUBE(grouping_column_reference_list)\n")),(0,s.yg)("p",null,"Example usage:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-sql"},'SELECT  \n        YEAR(d_date),  \n        i_category,  \n        ca_state,  \n        SUM(ss_net_paid) AS total_sum  \nFROM  \n        store_sales,  \n        date_dim d1,  \n        item,  \n        customer_address ca   \nWHERE  \n        d1.d_date_sk = ss_sold_date_sk  \n        AND i_item_sk = ss_item_sk  \n        AND ss_addr_sk = ca_address_sk  \n        AND i_category IN ("Books", "Electronics")  \n        AND YEAR(d_date) IN (1998, 1999)  \n        AND ca_state IN ("LA", "AK")  \nGROUP BY CUBE(YEAR(d_date), i_category, ca_state)  \nORDER BY YEAR(d_date), i_category, ca_state;\n')),(0,s.yg)("p",null,"The query result is as follows, calculating:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("p",{parentName:"li"},"The total sales sum;")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("p",{parentName:"li"},"Subtotals for sales by year, by product category, and by state;")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("p",{parentName:"li"},"Subtotals for sales by product category within each year, by state for each product, by state within each year, and by product category within each state and year."))),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-sql"},"+--------------+-------------+----------+------------+  \n| YEAR(d_date) | i_category  | ca_state | total_sum  |  \n+--------------+-------------+----------+------------+  \n|         NULL | NULL        | NULL     | 8690374.60 |  \n|         NULL | NULL        | AK       | 2675198.33 |  \n|         NULL | NULL        | LA       | 6015176.27 |  \n|         NULL | Books       | NULL     | 4238177.69 |  \n|         NULL | Books       | AK       | 1310791.36 |  \n|         NULL | Books       | LA       | 2927386.33 |  \n|         NULL | Electronics | NULL     | 4452196.91 |  \n|         NULL | Electronics | AK       | 1364406.97 |  \n|         NULL | Electronics | LA       | 3087789.94 |  \n|         1998 | NULL        | NULL     | 4369656.14 |  \n|         1998 | NULL        | AK       | 1402539.19 |  \n|         1998 | NULL        | LA       | 2967116.95 |  \n|         1998 | Books       | NULL     | 2213703.82 |  \n|         1998 | Books       | AK       |  719911.29 |  \n|         1998 | Books       | LA       | 1493792.53 |  \n|         1998 | Electronics | NULL     | 2155952.32 |  \n|         1998 | Electronics | AK       |  682627.90 |  \n|         1998 | Electronics | LA       | 1473324.42 |  \n|         1999 | NULL        | NULL     | 4320718.46 |  \n|         1999 | NULL        | AK       | 1272659.14 |  \n|         1999 | NULL        | LA       | 3048059.32 |  \n|         1999 | Books       | NULL     | 2024473.87 |  \n|         1999 | Books       | AK       |  590880.07 |  \n|         1999 | Books       | LA       | 1433593.80 |  \n|         1999 | Electronics | NULL     | 2296244.59 |  \n|         1999 | Electronics | AK       |  681779.07 |  \n|         1999 | Electronics | LA       | 1614465.52 |  \n+--------------+-------------+----------+------------+  \n27 rows in set (0.21 sec)\n")),(0,s.yg)("h2",{id:"grouping-function"},"GROUPING FUNCTION"),(0,s.yg)("p",null,"This section introduces how to address two challenges when using ROLLUP and CUBE:"),(0,s.yg)("ol",null,(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("p",{parentName:"li"},"How to programmatically identify which rows in the result set represent subtotals and accurately determine the aggregation level corresponding to a given subtotal. Since subtotals are often needed for calculations such as percentage of totals, we require a convenient method to identify these subtotal rows.")),(0,s.yg)("li",{parentName:"ol"},(0,s.yg)("p",{parentName:"li"},'When the query results contain both actual stored NULL values and "NULL" values generated by ROLLUP or CUBE operations, another problem arises: how to distinguish between these two types of NULL values?'))),(0,s.yg)("p",null,"GROUPING, GROUPING_ID, and GROUPING SETS can effectively solve the aforementioned challenges."),(0,s.yg)("h3",{id:"grouping"},"GROUPING"),(0,s.yg)("p",null,(0,s.yg)("strong",{parentName:"p"},"1. Principles")),(0,s.yg)("p",null,"GROUPING uses a single column as a parameter and returns 1 when encountering a NULL value created by ROLLUP or CUBE operations, indicating that the row is a subtotal. Any other type of value (including NULLs inherently present in the table data) returns 0."),(0,s.yg)("p",null,"Example:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-sql"},"select  \n        year(d_date),  \n        month(d_date),  \n        sum(ss_net_paid) as total_sum,  \n        grouping(year(d_date)),  \n        grouping(month(d_date))  \nfrom  \n        store_sales,  \n        date_dim d1  \nwhere  \n        d1.d_date_sk = ss_sold_date_sk  \n        and year(d_date) in (2001, 2002)  \n        and month(d_date) in (1, 2, 3)  \ngroup by  \n        rollup(year(d_date), month(d_date))  \norder by  \n        year(d_date), month(d_date);\n")),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("p",{parentName:"li"},"The GROUPING function result for the (YEAR(d_date), MONTH(d_date)) group is (0,0) for aggregation by year and month.")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("p",{parentName:"li"},"The GROUPING function result for the (YEAR(d_date)) group is (0,1) for aggregation by year.")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("p",{parentName:"li"},"The GROUPING function result for the () group is (1,1) for the total aggregation."))),(0,s.yg)("p",null,"Query result:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-Plain"},"+--------------+---------------+-------------+------------------------+-------------------------+  \n| year(d_date) | month(d_date) | total_sum   | Grouping(year(d_date)) | Grouping(month(d_date)) |  \n+--------------+---------------+-------------+------------------------+-------------------------+  \n|         NULL |          NULL | 54262669.17 |                      1 |                       1 |  \n|         2001 |          NULL | 26640320.46 |                      0 |                       1 |  \n|         2001 |             1 |  9982165.83 |                      0 |                       0 |  \n|         2001 |             2 |  8454915.34 |                      0 |                       0 |  \n|         2001 |             3 |  8203239.29 |                      0 |                       0 |  \n|         2002 |          NULL | 27622348.71 |                      0 |                       1 |  \n|         2002 |             1 | 11260654.35 |                      0 |                       0 |  \n|         2002 |             2 |  7722750.61 |                      0 |                       0 |  \n|         2002 |             3 |  8638943.75 |                      0 |                       0 |  \n+--------------+---------------+-------------+------------------------+-------------------------+  \n9 rows in set (0.06 sec)\n")),(0,s.yg)("p",null,(0,s.yg)("strong",{parentName:"p"},"2. Usage Scenarios, Syntax, and Examples")),(0,s.yg)("p",null,"The GROUPING function can be used to filter results. Example:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-sql"},'select\n        year(d_date),\n        i_category,\n        ca_state,\n        sum(ss_net_paid) as total_sum\nfrom\n        store_sales,\n        date_dim d1,\n        item,\n        customer_address ca \nwhere\n        d1.d_date_sk = ss_sold_date_sk\n        and i_item_sk = ss_item_sk\n        and ss_addr_sk=ca_address_sk\n        and i_category in ("Books", "Electronics")\n        and year(d_date) in(1998, 1999)\n        and ca_state in ("LA", "AK")\ngroup by cube(year(d_date), i_category, ca_state)\nhaving grouping(year(d_date))=1 and grouping(i_category)=1 and grouping(ca_state)=1\nor grouping(year(d_date))=0 and grouping(i_category)=1 and grouping(ca_state)=1\nor grouping(year(d_date))=1 and grouping(i_category)=1 and grouping(ca_state)=0\norder by year(d_date), i_category, ca_state;   \n')),(0,s.yg)("p",null,"Using the GROUPING function in the HAVING clause retains only the total sales, sales summarized by year, and sales summarized by region. Query result:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-Plain"},"+---------------------+------------+----------+------------+  \n| year(`d1`.`d_date`) | i_category | ca_state | total_sum  |  \n+---------------------+------------+----------+------------+  \n|                NULL | NULL       | NULL     | 8690374.60 |  \n|                NULL | NULL       | AK       | 2675198.33 |  \n|                NULL | NULL       | LA       | 6015176.27 |  \n|                1998 | NULL       | NULL     | 4369656.14 |  \n|                1999 | NULL       | NULL     | 4320718.46 |  \n+---------------------+------------+----------+------------+  \n5 rows in set (0.13 sec)\n")),(0,s.yg)("p",null,"You can also use the GROUPING function with the IF function to enhance query readability. Example:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-sql"},'select  \n        if(grouping(year(d_date)) = 1, "Multi-year sum", year(d_date)) as year,  \n        if(grouping(i_category) = 1, "Multi-category sum", i_category) as category,  \n        sum(ss_net_paid) as total_sum  \nfrom  \n        store_sales,  \n        date_dim d1,  \n        item,  \n        customer_address ca  \nwhere  \n        d1.d_date_sk = ss_sold_date_sk  \n        and i_item_sk = ss_item_sk  \n        and ss_addr_sk = ca_address_sk  \n        and i_category in ("Books", "Electronics")  \n        and year(d_date) in (1998, 1999)  \n        and ca_state in ("LA", "AK")  \ngroup by cube(year(d_date), i_category)\n')),(0,s.yg)("p",null,"Query result:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-sql"},"+----------------+--------------------+------------+  \n| year           | category           | total_sum  |  \n+----------------+--------------------+------------+  \n| 1998           | Books              | 2213703.82 |  \n| 1998           | Electronics        | 2155952.32 |  \n| 1999           | Electronics        | 2296244.59 |  \n| 1999           | Books              | 2024473.87 |  \n| 1998           | Multi-category sum | 4369656.14 |  \n| 1999           | Multi-category sum | 4320718.46 |  \n| Multi-year sum | Books              | 4238177.69 |  \n| Multi-year sum | Electronics        | 4452196.91 |  \n| Multi-year sum | Multi-category sum | 8690374.60 |  \n+----------------+--------------------+------------+  \n9 rows in set (0.09 sec)\n")),(0,s.yg)("h3",{id:"grouping_id"},"GROUPING_ID"),(0,s.yg)("p",null,(0,s.yg)("strong",{parentName:"p"},"1. Usage Scenarios")),(0,s.yg)("p",null,"In a database, both GROUPING_ID and GROUPING functions serve as auxiliary functions for handling multidimensional data aggregation queries, such as ROLLUP and CUBE, aiding users in distinguishing between different levels of aggregation results. If you wish to determine the aggregation level of a particular row, you need to use the GROUPING function to compute all GROUP BY columns, as the computation result of a single column alone is insufficient."),(0,s.yg)("p",null,"The GROUPING_ID function is more powerful than GROUPING because it can detect multiple columns simultaneously. The GROUPING_ID function accepts multiple columns as parameters and returns an integer that represents the aggregation status of these columns through binary bits. When using tables or materialized views to store computation results, using GROUPING to represent different levels of aggregation can consume considerable storage space. In such scenarios, GROUPING_ID is more appropriate."),(0,s.yg)("p",null,"Taking CUBE(a, b) as an example, its GROUPING_ID can be represented as follows:"),(0,s.yg)("table",null,(0,s.yg)("thead",{parentName:"table"},(0,s.yg)("tr",{parentName:"thead"},(0,s.yg)("th",{parentName:"tr",align:null},"Aggregation Level"),(0,s.yg)("th",{parentName:"tr",align:null},"Bit Vector"),(0,s.yg)("th",{parentName:"tr",align:null},"GROUPING_ID"),(0,s.yg)("th",{parentName:"tr",align:null},"GROUPING(a)"),(0,s.yg)("th",{parentName:"tr",align:null},"GROUPING(b)"))),(0,s.yg)("tbody",{parentName:"table"},(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"a,b"),(0,s.yg)("td",{parentName:"tr",align:null},"0 0"),(0,s.yg)("td",{parentName:"tr",align:null},"0"),(0,s.yg)("td",{parentName:"tr",align:null},"0"),(0,s.yg)("td",{parentName:"tr",align:null},"0")),(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"a"),(0,s.yg)("td",{parentName:"tr",align:null},"0 1"),(0,s.yg)("td",{parentName:"tr",align:null},"1"),(0,s.yg)("td",{parentName:"tr",align:null},"0"),(0,s.yg)("td",{parentName:"tr",align:null},"1")),(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"b"),(0,s.yg)("td",{parentName:"tr",align:null},"1 0"),(0,s.yg)("td",{parentName:"tr",align:null},"2"),(0,s.yg)("td",{parentName:"tr",align:null},"1"),(0,s.yg)("td",{parentName:"tr",align:null},"0")),(0,s.yg)("tr",{parentName:"tbody"},(0,s.yg)("td",{parentName:"tr",align:null},"Grand Total"),(0,s.yg)("td",{parentName:"tr",align:null},"1 1"),(0,s.yg)("td",{parentName:"tr",align:null},"3"),(0,s.yg)("td",{parentName:"tr",align:null},"1"),(0,s.yg)("td",{parentName:"tr",align:null},"1")))),(0,s.yg)("p",null,(0,s.yg)("strong",{parentName:"p"},"2. Syntax and Example")),(0,s.yg)("p",null,"Here is an example SQL query:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-sql"},"SELECT    \n    year(d_date),    \n    i_category,    \n    SUM(ss_net_paid) AS total_sum,    \n    GROUPING(year(d_date)),    \n    GROUPING(i_category),    \n    GROUPING_ID(year(d_date), i_category)    \nFROM    \n    store_sales,    \n    date_dim d1,    \n    item,    \n    customer_address ca     \nWHERE    \n    d1.d_date_sk = ss_sold_date_sk    \n    AND i_item_sk = ss_item_sk    \n    AND ss_addr_sk = ca_address_sk    \n    AND i_category IN ('Books', 'Electronics')    \n    AND year(d_date) IN (1998, 1999)    \n    AND ca_state IN ('LA', 'AK')    \nGROUP BY CUBE(year(d_date), i_category);\n")),(0,s.yg)("p",null,"The query results are as follows:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-sql"},"+--------------+-------------+------------+------------------------+----------------------+---------------------------------------+    \n| year(d_date) | i_category  | total_sum  | GROUPING(year(d_date)) | GROUPING(i_category) | GROUPING_ID(year(d_date), i_category) |    \n+--------------+-------------+------------+------------------------+----------------------+---------------------------------------+    \n| 1998         | Electronics | 2155952.32 | 0                      | 0                    | 0                                     |    \n| 1998         | Books       | 2213703.82 | 0                      | 0                    | 0                                     |    \n| 1999         | Electronics | 2296244.59 | 0                      | 0                    | 0                                     |    \n| 1999         | Books       | 2024473.87 | 0                      | 0                    | 0                                     |    \n| 1998         | NULL        | 4369656.14 | 0                      | 1                    | 1                                     |    \n| 1999         | NULL        | 4320718.46 | 0                      | 1                    | 1                                     |    \n| NULL         | Electronics | 4452196.91 | 1                      | 0                    | 2                                     |    \n| NULL         | Books       | 4238177.69 | 1                      | 0                    | 2                                     |    \n| NULL         | NULL        | 8690374.60 | 1                      | 1                    | 3                                     |    \n+--------------+-------------+------------+------------------------+----------------------+---------------------------------------+    \n9 rows in set (0.12 sec)\n")),(0,s.yg)("h3",{id:"grouping-sets"},"GROUPING SETS"),(0,s.yg)("p",null,(0,s.yg)("strong",{parentName:"p"},"1. Usage Scenarios")),(0,s.yg)("p",null,"When there is a need to selectively specify the group sets to create, the ",(0,s.yg)("inlineCode",{parentName:"p"},"GROUPING SETS")," expression can be used in the ",(0,s.yg)("inlineCode",{parentName:"p"},"GROUP BY")," clause. This method allows users to precisely specify across multiple dimensions without computing the entire CUBE."),(0,s.yg)("p",null,"Since CUBE queries typically consume significant resources, using ",(0,s.yg)("inlineCode",{parentName:"p"},"GROUPING SETS")," can enhance query execution efficiency when only a few dimensions are of interest."),(0,s.yg)("p",null,(0,s.yg)("strong",{parentName:"p"},"2. Syntax and Examples")),(0,s.yg)("p",null,"The syntax for ",(0,s.yg)("inlineCode",{parentName:"p"},"GROUPING SETS")," is as follows:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-sql"},"SELECT \u2026 GROUP BY GROUPING SETS(grouping_column_reference_list)\n")),(0,s.yg)("p",null,"If you need:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("p",{parentName:"li"},"Subtotals of sales for each product category per year")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("p",{parentName:"li"},"Subtotals of sales for each state per year")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("p",{parentName:"li"},"Subtotals of sales for each product in each state per year"))),(0,s.yg)("p",null,"You can use ",(0,s.yg)("inlineCode",{parentName:"p"},"GROUPING SETS")," to specify these dimensions and perform the aggregation. Here is an example:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-sql"},"SELECT  \n    YEAR(d_date),  \n    i_category,  \n    ca_state,  \n    SUM(ss_net_paid) AS total_sum  \nFROM  \n    store_sales,  \n    date_dim d1,  \n    item,  \n    customer_address ca   \nWHERE  \n    d1.d_date_sk = ss_sold_date_sk  \n    AND i_item_sk = ss_item_sk  \n    AND ss_addr_sk = ca_address_sk  \n    AND i_category IN ('Books', 'Electronics')  \n    AND YEAR(d_date) IN (1998, 1999)  \n    AND ca_state IN ('LA', 'AK')  \nGROUP BY GROUPING SETS(  \n    (YEAR(d_date), i_category),   \n    (YEAR(d_date), ca_state),   \n    (YEAR(d_date), ca_state, i_category)  \n)  \nORDER BY YEAR(d_date), i_category, ca_state;\n")),(0,s.yg)("p",null,"Query Result:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-sql"},"+--------------+-------------+----------+------------+  \n| YEAR(d_date) | i_category  | ca_state | total_sum  |  \n+--------------+-------------+----------+------------+  \n| 1998         | NULL        | AK       | 1402539.19 |  \n| 1998         | NULL        | LA       | 2967116.95 |  \n| 1998         | Books       | NULL     | 2213703.82 |  \n| 1998         | Books       | AK       |  719911.29 |  \n| 1998         | Books       | LA       | 1493792.53 |  \n| 1998         | Electronics | NULL     | 2155952.32 |  \n| 1998         | Electronics | AK       |  682627.90 |  \n| 1998         | Electronics | LA       | 1473324.42 |  \n| 1999         | NULL        | AK       | 1272659.14 |  \n| 1999         | NULL        | LA       | 3048059.32 |  \n| 1999         | Books       | NULL     | 2024473.87 |  \n| 1999         | Books       | AK       |  590880.07 |  \n| 1999         | Books       | LA       | 1433593.80 |  \n| 1999         | Electronics | NULL     | 2296244.59 |  \n| 1999         | Electronics | AK       |  681779.07 |  \n| 1999         | Electronics | LA       | 1614465.52 |  \n+--------------+-------------+----------+------------+  \n16 rows in set (0.11 sec)\n")),(0,s.yg)("p",null,"The above approach is equivalent to using CUBE but specifies concrete ",(0,s.yg)("inlineCode",{parentName:"p"},"grouping_id"),", thereby reducing unnecessary calculations:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-sql"},"SELECT  \n    SUM(ss_net_paid) AS total_sum,  \n    YEAR(d_date),  \n    i_category,  \n    ca_state  \nFROM  \n    store_sales,  \n    date_dim d1,  \n    item,  \n    customer_address ca   \nWHERE  \n    d1.d_date_sk = ss_sold_date_sk  \n    AND i_item_sk = ss_item_sk  \n    AND ss_addr_sk = ca_address_sk  \n    AND i_category IN ('Books', 'Electronics')  \n    AND YEAR(d_date) IN (1998, 1999)  \n    AND ca_state IN ('LA', 'AK')  \nGROUP BY CUBE(YEAR(d_date), ca_state, i_category)  \nHAVING grouping_id(YEAR(d_date), ca_state, i_category) = 0  \n    OR grouping_id(YEAR(d_date), ca_state, i_category) = 2   \n    OR grouping_id(YEAR(d_date), ca_state, i_category) = 1;\n")),(0,s.yg)("admonition",{title:"Note",type:"info"},(0,s.yg)("p",{parentName:"admonition"},"Using ",(0,s.yg)("inlineCode",{parentName:"p"},"CUBE")," computes all possible aggregation levels (eight in this case), but in practice, you may only be interested in a few of them.")),(0,s.yg)("p",null,(0,s.yg)("strong",{parentName:"p"},"3. Semantic Equivalents")),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("p",{parentName:"li"},"GROUPING SETS vs. GROUP BY UNION ALL"),(0,s.yg)("p",{parentName:"li"},"The ",(0,s.yg)("inlineCode",{parentName:"p"},"GROUPING SETS")," statement:"),(0,s.yg)("pre",{parentName:"li"},(0,s.yg)("code",{parentName:"pre",className:"language-sql"},"SELECT k1, k2, SUM(k3) FROM t GROUP BY GROUPING SETS ((k1, k2), (k1), (k2), ());\n")),(0,s.yg)("p",{parentName:"li"},"Is equivalent in query results to multiple ",(0,s.yg)("inlineCode",{parentName:"p"},"GROUP BY")," queries connected with ",(0,s.yg)("inlineCode",{parentName:"p"},"UNION ALL"),":"),(0,s.yg)("pre",{parentName:"li"},(0,s.yg)("code",{parentName:"pre",className:"language-sql"},"SELECT k1, k2, SUM(k3) FROM t GROUP BY k1, k2  \nUNION ALL  \nSELECT k1, NULL, SUM(k3) FROM t GROUP BY k1  \nUNION ALL  \nSELECT NULL, k2, SUM(k3) FROM t GROUP BY k2  \nUNION ALL  \nSELECT NULL, NULL, SUM(k3) FROM t;\n")),(0,s.yg)("p",{parentName:"li"},"Using ",(0,s.yg)("inlineCode",{parentName:"p"},"UNION ALL")," results in a longer query and requires multiple scans of the base table, making it less efficient in both writing and execution.")),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("p",{parentName:"li"},"GROUPING SETS vs. ROLLUP"),(0,s.yg)("p",{parentName:"li"},(0,s.yg)("inlineCode",{parentName:"p"},"ROLLUP")," is an extension of ",(0,s.yg)("inlineCode",{parentName:"p"},"GROUPING SETS"),". For example:"),(0,s.yg)("pre",{parentName:"li"},(0,s.yg)("code",{parentName:"pre",className:"language-sql"},"SELECT a, b, c, SUM(d) FROM tab1 GROUP BY ROLLUP(a, b, c);\n")),(0,s.yg)("p",{parentName:"li"},"This ",(0,s.yg)("inlineCode",{parentName:"p"},"ROLLUP")," is equivalent to the following ",(0,s.yg)("inlineCode",{parentName:"p"},"GROUPING SETS"),":"),(0,s.yg)("pre",{parentName:"li"},(0,s.yg)("code",{parentName:"pre",className:"language-sql"},"GROUPING SETS (  \n    (a, b, c),  \n    (a, b),  \n    (a),  \n    ()  \n);\n"))),(0,s.yg)("li",{parentName:"ul"},(0,s.yg)("p",{parentName:"li"},"GROUPING SETS vs. CUBE"),(0,s.yg)("p",{parentName:"li"},(0,s.yg)("inlineCode",{parentName:"p"},"CUBE(a, b, c)")," is equivalent to the following ",(0,s.yg)("inlineCode",{parentName:"p"},"GROUPING SETS"),":"),(0,s.yg)("pre",{parentName:"li"},(0,s.yg)("code",{parentName:"pre",className:"language-sql"},"GROUPING SETS (  \n    (a, b, c),  \n    (a, b),  \n    (a, c),  \n    (a),  \n    (b, c),  \n    (b),  \n    (c),  \n    ()  \n);\n")))),(0,s.yg)("h2",{id:"design-document"},"Design Document"),(0,s.yg)("p",null,"For detailed information, please refer to ",(0,s.yg)("a",{parentName:"p",href:"https://www.oracle.com/path-to-reference-documentation"},"SQL for Aggregation in Data Warehouses")," on the Oracle official website."))}c.isMDXComponent=!0}}]);