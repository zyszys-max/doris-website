"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([[996266],{15680:(e,n,t)=>{t.d(n,{xA:()=>m,yg:()=>g});var a=t(296540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var p=a.createContext({}),s=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},m=function(e){var n=s(e.components);return a.createElement(p.Provider,{value:n},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,l=e.originalType,p=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),d=s(t),u=i,g=d["".concat(p,".").concat(u)]||d[u]||c[u]||l;return t?a.createElement(g,r(r({ref:n},m),{},{components:t})):a.createElement(g,r({ref:n},m))}));function g(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var l=t.length,r=new Array(l);r[0]=u;var o={};for(var p in n)hasOwnProperty.call(n,p)&&(o[p]=n[p]);o.originalType=e,o[d]="string"==typeof e?e:i,r[1]=o;for(var s=2;s<l;s++)r[s]=t[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},611225:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>r,default:()=>c,frontMatter:()=>l,metadata:()=>o,toc:()=>s});var a=t(58168),i=(t(296540),t(15680));const l={title:"CREATE-TABLE",language:"en",toc_min_heading_level:2,toc_max_heading_level:4},r=void 0,o={unversionedId:"sql-manual/sql-statements/Data-Definition-Statements/Create/CREATE-TABLE",id:"version-2.1/sql-manual/sql-statements/Data-Definition-Statements/Create/CREATE-TABLE",title:"CREATE-TABLE",description:"\x3c!--",source:"@site/versioned_docs/version-2.1/sql-manual/sql-statements/Data-Definition-Statements/Create/CREATE-TABLE.md",sourceDirName:"sql-manual/sql-statements/Data-Definition-Statements/Create",slug:"/sql-manual/sql-statements/Data-Definition-Statements/Create/CREATE-TABLE",permalink:"/docs/sql-manual/sql-statements/Data-Definition-Statements/Create/CREATE-TABLE",draft:!1,tags:[],version:"2.1",frontMatter:{title:"CREATE-TABLE",language:"en",toc_min_heading_level:2,toc_max_heading_level:4},sidebar:"docs",previous:{title:"CREATE-DATABASE",permalink:"/docs/sql-manual/sql-statements/Data-Definition-Statements/Create/CREATE-DATABASE"},next:{title:"CREATE-TABLE-LIKE",permalink:"/docs/sql-manual/sql-statements/Data-Definition-Statements/Create/CREATE-TABLE-LIKE"}},p={},s=[{value:"CREATE-TABLE",id:"create-table",level:2},{value:"Description",id:"description",level:3},{value:"column_definition_list",id:"column_definition_list",level:4},{value:"index_definition_list",id:"index_definition_list",level:4},{value:"engine_type",id:"engine_type",level:4},{value:"keys_type",id:"keys_type",level:4},{value:"table_comment",id:"table_comment",level:4},{value:"partition_info",id:"partition_info",level:4},{value:"distribution_desc",id:"distribution_desc",level:4},{value:"rollup_list",id:"rollup_list",level:4},{value:"properties",id:"properties",level:4},{value:"Example",id:"example",level:3},{value:"Keywords",id:"keywords",level:3},{value:"Best Practice",id:"best-practice",level:3},{value:"Partitioning and bucketing",id:"partitioning-and-bucketing",level:4},{value:"Dynamic Partition",id:"dynamic-partition",level:4},{value:"Auto Partition",id:"auto-partition",level:4},{value:"Materialized View",id:"materialized-view",level:4},{value:"Index",id:"index",level:4}],m={toc:s},d="wrapper";function c(e){let{components:n,...t}=e;return(0,i.yg)(d,(0,a.A)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h2",{id:"create-table"},"CREATE-TABLE"),(0,i.yg)("h3",{id:"description"},"Description"),(0,i.yg)("p",null,"This command is used to create a table. The subject of this document describes the syntax for creating Doris self-maintained tables."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE [IF NOT EXISTS] [database.]table\n(\n    column_definition_list\n    [, index_definition_list]\n)\n[engine_type]\n[keys_type]\n[table_comment]\n[partition_info]\ndistribution_desc\n[rollup_list]\n[properties]\n[extra_properties]\n")),(0,i.yg)("h4",{id:"column_definition_list"},"column_definition_list"),(0,i.yg)("p",null,"Column definition list:"),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"column_definition[, column_definition]")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"column_definition")),(0,i.yg)("p",{parentName:"li"},"  Column definition:"),(0,i.yg)("p",{parentName:"li"},"  ",(0,i.yg)("inlineCode",{parentName:"p"},"column_name column_type [KEY] [aggr_type] [NULL] [AUTO_INCREMENT(auto_inc_start_value)] [default_value] [on update current_timestamp] [column_comment]")),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"column_type")),(0,i.yg)("p",{parentName:"li"},"  Column type, the following types are supported:"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},"TINYINT (1 byte)\n    Range: -2^7 + 1 ~ 2^7-1\nSMALLINT (2 bytes)\n    Range: -2^15 + 1 ~ 2^15-1\nINT (4 bytes)\n    Range: -2^31 + 1 ~ 2^31-1\nBIGINT (8 bytes)\n    Range: -2^63 + 1 ~ 2^63-1\nLARGEINT (16 bytes)\n    Range: -2^127 + 1 ~ 2^127-1\nFLOAT (4 bytes)\n    Support scientific notation\nDOUBLE (12 bytes)\n    Support scientific notation\nDECIMAL[(precision, scale)] (16 bytes)\n    The decimal type with guaranteed precision. The default is DECIMAL(10, 0)\n    precision: 1 ~ 27\n    scale: 0 ~ 9\n    Where the integer part is 1 ~ 18\n    Does not support scientific notation\nDATE (3 bytes)\n    Range: 0000-01-01 ~ 9999-12-31\nDATETIME (8 bytes)\n    Range: 0000-01-01 00:00:00 ~ 9999-12-31 23:59:59\nCHAR[(length)]\n    Fixed-length character string. Length range: 1 ~ 255. Default is 1\nVARCHAR[(length)]\n    Variable length character string. Length range: 1 ~ 65533. Default is 65533\nHLL (1~16385 bytes)\n    HyperLogLog column type, do not need to specify the length and default value. The length is controlled within the system according to the degree of data aggregation.\n    Must be used with HLL_UNION aggregation type.\nBITMAP\n    The bitmap column type does not need to specify the length and default value. Represents a collection of integers, and the maximum number of elements supported is 2^64-1.\n    Must be used with BITMAP_UNION aggregation type.\n"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"aggr_type")),(0,i.yg)("p",{parentName:"li"},"  Aggregation type, the following aggregation types are supported:"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},"SUM: Sum. Applicable numeric types.\nMIN: Find the minimum value. Suitable for numeric types.\nMAX: Find the maximum value. Suitable for numeric types.\nREPLACE: Replace. For rows with the same dimension column, the index column will be imported in the order of import, and the last imported will replace the first imported.\nREPLACE_IF_NOT_NULL: non-null value replacement. The difference with REPLACE is that there is no replacement for null values. It should be noted here that the default value should be NULL, not an empty string. If it is an empty string, you should replace it with an empty string.\nHLL_UNION: The aggregation method of HLL type columns, aggregated by HyperLogLog algorithm.\nBITMAP_UNION: The aggregation mode of BIMTAP type columns, which performs the union aggregation of bitmaps.\n"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"AUTO_INCREMENT(auto_inc_start_value)")),(0,i.yg)("p",{parentName:"li"},"  To indicate if the column is a auto-increment column. Auto-increment column can be used to generate a unique identity for new row. If no values are assgined for auto-increment column when inserting, Doris will generate sequence numbers automatically. You can also assign the auto-increment column with NULL literal to indicate Doris to generate sequence numbers. It should be noted that, for performance reasons, BE will cache some values of auto-increment column in memory. Therefore, the values generated by auto-increment column can only guarantee monotonicity and uniqueness, but not strict continuity.\nA table can have at most one auto-incremnt column. The auto-increment column should be BIGINT type and be NOT NULL.\nBoth Duplicate model table and Unique model table support auto-increment column.\nYou can specify the starting value for an auto-increment column by providing `auto_inc_start_value. If not specified, the default starting value is 1.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"default_value")),(0,i.yg)("p",{parentName:"li"},"  Default value of the column. If the load data does not specify a value for this column, the system will assign a default value to this column."),(0,i.yg)("p",{parentName:"li"},"  The syntax is: ",(0,i.yg)("inlineCode",{parentName:"p"},"default default_value"),"."),(0,i.yg)("p",{parentName:"li"},"  Currently, the default value supports two forms:"),(0,i.yg)("ol",{parentName:"li"},(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"The user specifies a fixed value, such as:"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-SQL"},"    k1 INT DEFAULT '1',\n    k2 CHAR(10) DEFAULT 'aaaa'\n"))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Keywords are provided by the system. Currently, the following keywords are supported: "),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-SQL"},"    // This keyword is used only for DATETIME type. If the value is missing, the system assigns the current timestamp.\n    dt DATETIME DEFAULT CURRENT_TIMESTAMP\n"))))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"on update current_timestamp")),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},'To indicate that whether the value of this column should be updated to the current timestamp (`current_timestamp`) when there is an update on the row. The feature is only available on unique table with merge-on-write enabled. Columns with this feature enabled must declare a default value, and the default value must be `current_timestamp`. If the precision of the timestamp is declared here, the timestamp precision in the default value of the column must be the same as the precision declared here."\n')),(0,i.yg)("p",{parentName:"li"},"Example:"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},'```\nk1 TINYINT,\nk2 DECIMAL(10,2) DEFAULT "10.5",\nk4 BIGINT NULL DEFAULT "1000" COMMENT "This is column k4",\nv1 VARCHAR(10) REPLACE NOT NULL,\nv2 BITMAP BITMAP_UNION,\nv3 HLL HLL_UNION,\nv4 INT SUM NOT NULL DEFAULT "1" COMMENT "This is column v4"\ndt datetime(6) default current_timestamp(6) on update current_timestamp(6)\n```\n')))))),(0,i.yg)("h4",{id:"index_definition_list"},"index_definition_list"),(0,i.yg)("p",null,"Index list definition:"),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"index_definition[, index_definition]")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"index_definition")),(0,i.yg)("p",{parentName:"li"},"  Index definition:"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-sql"},"INDEX index_name (col_name) [USING INVERTED] COMMENT'xxxxxx'\n")),(0,i.yg)("p",{parentName:"li"},"  Example:"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-sql"},'INDEX idx1 (k1) USING INVERTED COMMENT "This is a inverted index1",\nINDEX idx2 (k2) USING INVERTED COMMENT "This is a inverted index2",\n...\n')))),(0,i.yg)("h4",{id:"engine_type"},"engine_type"),(0,i.yg)("p",null,"Table engine type. All types in this document are OLAP. Example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"`ENGINE=olap`\n")),(0,i.yg)("h4",{id:"keys_type"},"keys_type"),(0,i.yg)("p",null,"Data model."),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"key_type(col1, col2, ...)")),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"key_type")," supports the following models:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"DUPLICATE KEY (default): The subsequent specified column is the sorting column."),(0,i.yg)("li",{parentName:"ul"},"AGGREGATE KEY: The specified column is the dimension column."),(0,i.yg)("li",{parentName:"ul"},"UNIQUE KEY: The subsequent specified column is the primary key column.")),(0,i.yg)("p",null,"NOTE: when set table property ",(0,i.yg)("inlineCode",{parentName:"p"},'"enable_duplicate_without_keys_by_default" = "true"'),", will create a duplicate model without sorting columns and prefix indexes by default."),(0,i.yg)("p",null,"Example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"DUPLICATE KEY(col1, col2),\nAGGREGATE KEY(k1, k2, k3),\nUNIQUE KEY(k1, k2)\n")),(0,i.yg)("h4",{id:"table_comment"},"table_comment"),(0,i.yg)("p",null,"Table notes. Example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'```\nCOMMENT "This is my first DORIS table"\n```\n')),(0,i.yg)("h4",{id:"partition_info"},"partition_info"),(0,i.yg)("p",null,"Partition information supports three writing methods:"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"LESS THAN: Only define the upper boundary of the partition. The lower bound is determined by the upper bound of the previous partition."),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},'PARTITION BY RANGE(col1[, col2, ...])\n(\n    PARTITION partition_name1 VALUES LESS THAN MAXVALUE|("value1", "value2", ...),\n    PARTITION partition_name2 VALUES LESS THAN MAXVALUE|("value1", "value2", ...)\n)\n'))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"FIXED RANGE: Define the left closed and right open interval of the zone."),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},'PARTITION BY RANGE(col1[, col2, ...])\n(\n    PARTITION partition_name1 VALUES [("k1-lower1", "k2-lower1", "k3-lower1",...), ("k1-upper1", "k2-upper1", "k3-upper1", ... )),\n    PARTITION partition_name2 VALUES [("k1-lower1-2", "k2-lower1-2", ...), ("k1-upper1-2", MAXVALUE, ))\n)\n')))),(0,i.yg)("ol",{start:3},(0,i.yg)("li",{parentName:"ol"},"MULTI RANGE: Multi build RANGE partitions,Define the left closed and right open interval of the zone, Set the time unit and step size, the time unit supports year, month, day, week and hour.")),(0,i.yg)("admonition",{title:"Tips",type:"tip"},(0,i.yg)("p",{parentName:"admonition"},"This feature is supported since the Apache Doris 1.2 version")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'```\nPARTITION BY RANGE(col)\n(\n   FROM ("2000-11-14") TO ("2021-11-14") INTERVAL 1 YEAR,\n   FROM ("2021-11-14") TO ("2022-11-14") INTERVAL 1 MONTH,\n   FROM ("2022-11-14") TO ("2023-01-03") INTERVAL 1 WEEK,\n   FROM ("2023-01-03") TO ("2023-01-14") INTERVAL 1 DAY\n)\n```\n')),(0,i.yg)("ol",{start:4},(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"MULTI RANGE: Multi build integer RANGE partitions,Define the left closed and right open interval of the zone, and step size."),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},"PARTITION BY RANGE(int_col)\n(\n    FROM (1) TO (100) INTERVAL 10\n)\n")))),(0,i.yg)("h4",{id:"distribution_desc"},"distribution_desc"),(0,i.yg)("p",null,"Define the data bucketing method."),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Hash\nSyntax:\n",(0,i.yg)("inlineCode",{parentName:"p"},"DISTRIBUTED BY HASH (k1[,k2 ...]) [BUCKETS num|auto]"),"\nExplain:\nHash bucketing using the specified key column. ")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Random\nSyntax:\n",(0,i.yg)("inlineCode",{parentName:"p"},"DISTRIBUTED BY RANDOM [BUCKETS num|auto]"),"\nExplain:\nUse random numbers for bucketing."))),(0,i.yg)("h4",{id:"rollup_list"},"rollup_list"),(0,i.yg)("p",null,"Multiple materialized views (ROLLUP) can be created at the same time as the table is built."),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"ROLLUP (rollup_definition[, rollup_definition, ...])")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"rollup_definition")),(0,i.yg)("p",{parentName:"li"},"  ",(0,i.yg)("inlineCode",{parentName:"p"},'rollup_name (col1[, col2, ...]) [DUPLICATE KEY(col1[, col2, ...])] [PROPERTIES("key" = "value")]')),(0,i.yg)("p",{parentName:"li"},"  Example:"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},"ROLLUP (\n    r1 (k1, k3, v1, v2),\n    r2 (k1, v1)\n)\n")))),(0,i.yg)("h4",{id:"properties"},"properties"),(0,i.yg)("p",null,"Set table properties. The following attributes are currently supported:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"replication_num")),(0,i.yg)("p",{parentName:"li"}," Number of copies. The default number of copies is 3. If the number of BE nodes is less than 3, you need to specify that the number of copies is less than or equal to the number of BE nodes."),(0,i.yg)("p",{parentName:"li"}," After version 0.15, this attribute will be automatically converted to the ",(0,i.yg)("inlineCode",{parentName:"p"},"replication_allocation")," attribute, such as:"),(0,i.yg)("p",{parentName:"li"}," ",(0,i.yg)("inlineCode",{parentName:"p"},'"replication_num" = "3"')," will be automatically converted to ",(0,i.yg)("inlineCode",{parentName:"p"},'"replication_allocation" = "tag.location.default:3"'))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"replication_allocation")),(0,i.yg)("p",{parentName:"li"},"  Set the copy distribution according to Tag. This attribute can completely cover the function of the ",(0,i.yg)("inlineCode",{parentName:"p"},"replication_num")," attribute.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"min_load_replica_num")),(0,i.yg)("p",{parentName:"li"},"  The minimum required successful replica num for loading data. The default value is ",(0,i.yg)("inlineCode",{parentName:"p"},"-1"),". If set less than or equal to 0, loading data requires a majority replicas to succeed.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"is_being_synced"),"  "),(0,i.yg)("p",{parentName:"li"},"  Used to identify whether this table is copied by CCR and is being synchronized by syncer. The default is ",(0,i.yg)("inlineCode",{parentName:"p"},"false"),".  "),(0,i.yg)("p",{parentName:"li"},"  If set to ",(0,i.yg)("inlineCode",{parentName:"p"},"true"),":",(0,i.yg)("br",{parentName:"p"}),"\n","",(0,i.yg)("inlineCode",{parentName:"p"},"colocate_with"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"storage_policy")," properties will be erased",(0,i.yg)("br",{parentName:"p"}),"\n","",(0,i.yg)("inlineCode",{parentName:"p"},"dynamic partition"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"auto bucket")," features will be disabled, that is, they will be displayed as enabled in ",(0,i.yg)("inlineCode",{parentName:"p"},"show create table"),", but will not actually take effect. When ",(0,i.yg)("inlineCode",{parentName:"p"},"is_being_synced")," is set to ",(0,i.yg)("inlineCode",{parentName:"p"},"false"),", these features will resume working.  "),(0,i.yg)("p",{parentName:"li"},"  This property is for CCR peripheral modules only and should not be manually set during CCR synchronization.  ")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"storage_medium/storage_cooldown_time")),(0,i.yg)("p",{parentName:"li"}," Data storage medium. ",(0,i.yg)("inlineCode",{parentName:"p"},"storage_medium")," is used to declare the initial storage medium of the table data, and ",(0,i.yg)("inlineCode",{parentName:"p"},"storage_cooldown_time")," is used to set the expiration time. Example:"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},'"storage_medium" = "SSD",\n"storage_cooldown_time" = "2020-11-20 00:00:00"\n')),(0,i.yg)("p",{parentName:"li"}," This example indicates that the data is stored in the SSD and will be automatically migrated to the HDD storage after the expiration of 2020-11-20 00:00:00.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"colocate_with")),(0,i.yg)("p",{parentName:"li"}," When you need to use the Colocation Join function, use this parameter to set the Colocation Group."),(0,i.yg)("p",{parentName:"li"}," ",(0,i.yg)("inlineCode",{parentName:"p"},'"colocate_with" = "group1"'))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"bloom_filter_columns")),(0,i.yg)("p",{parentName:"li"}," The user specifies the list of column names that need to be added to the Bloom Filter index. The Bloom Filter index of each column is independent, not a composite index."),(0,i.yg)("p",{parentName:"li"}," ",(0,i.yg)("inlineCode",{parentName:"p"},'"bloom_filter_columns" = "k1, k2, k3"'))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"in_memory")),(0,i.yg)("p",{parentName:"li"}," Deprecated.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"function_column.sequence_col")),(0,i.yg)("p",{parentName:"li"}," When using the UNIQUE KEY model, you can specify a sequence column. When the KEY columns are the same, REPLACE will be performed according to the sequence column (the larger value replaces the smaller value, otherwise it cannot be replaced)"),(0,i.yg)("p",{parentName:"li"},"The ",(0,i.yg)("inlineCode",{parentName:"p"},"function_column.sequence_col")," is used to specify the mapping of the sequence column to a column in the table, which can be integral and time (DATE, DATETIME). The type of this column cannot be changed after creation. If ",(0,i.yg)("inlineCode",{parentName:"p"},"function_column.sequence_col")," is set, ",(0,i.yg)("inlineCode",{parentName:"p"},"function_column.sequence_type")," is ignored."),(0,i.yg)("p",{parentName:"li"}," ",(0,i.yg)("inlineCode",{parentName:"p"},"\"function_column.sequence_col\" ='column_name'"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"function_column.sequence_type")),(0,i.yg)("p",{parentName:"li"}," When using the UNIQUE KEY model, you can specify a sequence column. When the KEY columns are the same, REPLACE will be performed according to the sequence column (the larger value replaces the smaller value, otherwise it cannot be replaced)"),(0,i.yg)("p",{parentName:"li"}," Here we only need to specify the type of sequence column, support time type or integer type. Doris will create a hidden sequence column."),(0,i.yg)("p",{parentName:"li"}," ",(0,i.yg)("inlineCode",{parentName:"p"},"\"function_column.sequence_type\" ='Date'"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"compression")),(0,i.yg)("p",{parentName:"li"}," The default compression method for Doris tables is LZ4. After version 1.1, it is supported to specify the compression method as ZSTD to obtain a higher compression ratio."),(0,i.yg)("p",{parentName:"li"}," ",(0,i.yg)("inlineCode",{parentName:"p"},'"compression"="zstd"'))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"enable_unique_key_merge_on_write")),(0,i.yg)("p",{parentName:"li"},"  Wheather the unique table use merge-on-write implementation. "),(0,i.yg)("p",{parentName:"li"},"  The property is disabled by default before version 2.1 and is enabled by default since version 2.1.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"light_schema_change")),(0,i.yg)("p",{parentName:"li"}," Whether to use the Light Schema Change optimization."),(0,i.yg)("p",{parentName:"li"}," If set to true, the addition and deletion of value columns can be done more quickly and synchronously."),(0,i.yg)("p",{parentName:"li"}," ",(0,i.yg)("inlineCode",{parentName:"p"},'"light_schema_change"="true"')),(0,i.yg)("p",{parentName:"li"}," This feature is enabled by default after v2.0.0.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"disable_auto_compaction")),(0,i.yg)("p",{parentName:"li"}," Whether to disable automatic compaction for this table."),(0,i.yg)("p",{parentName:"li"}," If this property is set to 'true', the background automatic compaction process will skip all the tables of this table."),(0,i.yg)("p",{parentName:"li"}," ",(0,i.yg)("inlineCode",{parentName:"p"},'"disable_auto_compaction" = "false"'))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"enable_single_replica_compaction")),(0,i.yg)("p",{parentName:"li"}," Whether to enable single replica compaction for this table."),(0,i.yg)("p",{parentName:"li"}," If this property is set to 'true', all replicas of the tablet will only have one replica performing compaction, while the others fetch rowsets from that replica."),(0,i.yg)("p",{parentName:"li"}," ",(0,i.yg)("inlineCode",{parentName:"p"},'"enable_single_replica_compaction" = "false"'))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"enable_duplicate_without_keys_by_default")),(0,i.yg)("p",{parentName:"li"}," When ",(0,i.yg)("inlineCode",{parentName:"p"},"true"),", if Unique, Aggregate, or Duplicate is not specified when creating a table, a Duplicate model table without sorting columns and prefix indexes will be created by default."),(0,i.yg)("p",{parentName:"li"}," ",(0,i.yg)("inlineCode",{parentName:"p"},'"enable_duplicate_without_keys_by_default" = "false"'))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"skip_write_index_on_load")),(0,i.yg)("p",{parentName:"li"}," Whether to enable skip inverted index on load for this table."),(0,i.yg)("p",{parentName:"li"}," If this property is set to 'true', skip writting index (only inverted index now) on first time load and delay writting\nindex to compaction. It can reduce CPU and IO resource usage for high throughput load."),(0,i.yg)("p",{parentName:"li"}," ",(0,i.yg)("inlineCode",{parentName:"p"},'"skip_write_index_on_load" = "false"'))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"compaction_policy")),(0,i.yg)("p",{parentName:"li"},'  Configure the compaction strategy in the compression phase. Only support configuring the compaction policy as "time_series" or "size_based".'),(0,i.yg)("p",{parentName:"li"},"  time_series: When the disk size of a rowset accumulates to a certain threshold, version merging takes place. The merged rowset is directly promoted to the base compaction stage. This approach effectively reduces the write amplification rate of compaction, especially in scenarios with continuous imports in a time series context."),(0,i.yg)("p",{parentName:"li"},"  In the case of time series compaction, the execution of compaction is adjusted using parameters that have the prefix time_series_compaction."),(0,i.yg)("p",{parentName:"li"},"  ",(0,i.yg)("inlineCode",{parentName:"p"},'"compaction_policy" = ""'))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"group_commit_interval_ms")),(0,i.yg)("p",{parentName:"li"},"  Configures the group commit batch interval for this table. The unit is milliseconds, with a default value of 10000ms (10 seconds)."),(0,i.yg)("p",{parentName:"li"},"  The flushing timing of group commit depends on which value is reached first: ",(0,i.yg)("inlineCode",{parentName:"p"},"group_commit_interval_ms")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"group_commit_data_bytes"),"."),(0,i.yg)("p",{parentName:"li"},"  ",(0,i.yg)("inlineCode",{parentName:"p"},'"group_commit_interval_ms" = "10000"'))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"group_commit_data_bytes")),(0,i.yg)("p",{parentName:"li"},"  Configures the group commit batch data size for this table. The unit is bytes, with a default value of 134217728 bytes (128MB)."),(0,i.yg)("p",{parentName:"li"},"  The flushing timing of group commit depends on which value is reached first: ",(0,i.yg)("inlineCode",{parentName:"p"},"group_commit_interval_ms")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"group_commit_data_bytes"),"."),(0,i.yg)("p",{parentName:"li"},"  ",(0,i.yg)("inlineCode",{parentName:"p"},'"group_commit_data_bytes" = "134217728"'))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"time_series_compaction_goal_size_mbytes")),(0,i.yg)("p",{parentName:"li"},"  Time series compaction policy will utilize this parameter to adjust the size of input files for each compaction. The output file size will be approximately equal to the input file size."),(0,i.yg)("p",{parentName:"li"},"  ",(0,i.yg)("inlineCode",{parentName:"p"},'"time_series_compaction_goal_size_mbytes" = "1024"'))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"time_series_compaction_file_count_threshold")),(0,i.yg)("p",{parentName:"li"},"  Time series compaction policy will utilize this parameter to adjust the minimum number of input files for each compaction."),(0,i.yg)("p",{parentName:"li"},"  If the number of files in a tablet exceeds the configured threshold, it will trigger a compaction process."),(0,i.yg)("p",{parentName:"li"},"  ",(0,i.yg)("inlineCode",{parentName:"p"},'"time_series_compaction_file_count_threshold" = "2000"'))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"time_series_compaction_time_threshold_seconds")),(0,i.yg)("p",{parentName:"li"},"   When time series compaction policy is applied, a significant duration passes without a compaction being executed, a compaction will be triggered."),(0,i.yg)("p",{parentName:"li"},"  ",(0,i.yg)("inlineCode",{parentName:"p"},'"time_series_compaction_time_threshold_seconds" = "3600"'))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("inlineCode",{parentName:"p"},"enable_mow_light_delete")),(0,i.yg)("p",{parentName:"li"},"  If modify delete predicate for the DELETE statement on the unique merge-on-write table. If enabled, it will improve the performance of the DELETE statement, but errors may occur in partial column updates after deletion. If disabled, it will reduce the performance of the DELETE statement to ensure correctness."),(0,i.yg)("p",{parentName:"li"},"  The default value for this property is false."),(0,i.yg)("p",{parentName:"li"},"  This propertiy can only be enabled on unique merge-on-write tables."),(0,i.yg)("p",{parentName:"li"},"  ",(0,i.yg)("inlineCode",{parentName:"p"},'"enable_mow_light_delete" = "true"'))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"Dynamic partition related"))),(0,i.yg)("p",null,"References related to dynamic partitioning",(0,i.yg)("a",{parentName:"p",href:"../../../../table-design/data-partitioning/dynamic-partitioning"},"Data Partitioning-Dynamic partitioning")),(0,i.yg)("h3",{id:"example"},"Example"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Create a detailed model table"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE example_db.table_hash\n(\n    k1 TINYINT,\n    k2 DECIMAL(10, 2) DEFAULT "10.5",\n    k3 CHAR(10) COMMENT "string column",\n    k4 INT NOT NULL DEFAULT "1" COMMENT "int column"\n)\nCOMMENT "my first table"\nDISTRIBUTED BY HASH(k1) BUCKETS 32\n'))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Create a detailed model table, partition, specify the sorting column, and set the number of copies to 1"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE example_db.table_hash\n(\n    k1 DATE,\n    k2 DECIMAL(10, 2) DEFAULT "10.5",\n    k3 CHAR(10) COMMENT "string column",\n    k4 INT NOT NULL DEFAULT "1" COMMENT "int column"\n)\nDUPLICATE KEY(k1, k2)\nCOMMENT "my first table"\nPARTITION BY RANGE(k1)\n(\n    PARTITION p1 VALUES LESS THAN ("2020-02-01"),\n    PARTITION p2 VALUES LESS THAN ("2020-03-01"),\n    PARTITION p3 VALUES LESS THAN ("2020-04-01")\n)\nDISTRIBUTED BY HASH(k1) BUCKETS 32\nPROPERTIES (\n    "replication_num" = "1"\n);\n'))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Create a table with a unique model of the primary key, set the initial storage medium and cooling time"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE example_db.table_hash\n(\n    k1 BIGINT,\n    k2 LARGEINT,\n    v1 VARCHAR(2048),\n    v2 SMALLINT DEFAULT "10"\n)\nUNIQUE KEY(k1, k2)\nDISTRIBUTED BY HASH (k1, k2) BUCKETS 32\nPROPERTIES(\n    "storage_medium" = "SSD",\n    "storage_cooldown_time" = "2015-06-04 00:00:00"\n);\n'))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Create an aggregate model table, using a fixed range partition description"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE table_range\n(\n    k1 DATE,\n    k2 INT,\n    k3 SMALLINT,\n    v1 VARCHAR(2048) REPLACE,\n    v2 INT SUM DEFAULT "1"\n)\nAGGREGATE KEY(k1, k2, k3)\nPARTITION BY RANGE (k1, k2, k3)\n(\n    PARTITION p1 VALUES [("2014-01-01", "10", "200"), ("2014-01-01", "20", "300")),\n    PARTITION p2 VALUES [("2014-06-01", "100", "200"), ("2014-07-01", "100", "300"))\n)\nDISTRIBUTED BY HASH(k2) BUCKETS 32\n'))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Create an aggregate model table with HLL and BITMAP column types"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE example_db.example_table\n(\n    k1 TINYINT,\n    k2 DECIMAL(10, 2) DEFAULT "10.5",\n    v1 HLL HLL_UNION,\n    v2 BITMAP BITMAP_UNION\n)\nENGINE=olap\nAGGREGATE KEY(k1, k2)\nDISTRIBUTED BY HASH(k1) BUCKETS 32\n'))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Create two self-maintained tables of the same Colocation Group."),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE t1 (\n    id int(11) COMMENT "",\n    value varchar(8) COMMENT ""\n)\nDUPLICATE KEY(id)\nDISTRIBUTED BY HASH(id) BUCKETS 10\nPROPERTIES (\n    "colocate_with" = "group1"\n);\n\nCREATE TABLE t2 (\n    id int(11) COMMENT "",\n    value1 varchar(8) COMMENT "",\n    value2 varchar(8) COMMENT ""\n)\nDUPLICATE KEY(`id`)\nDISTRIBUTED BY HASH(`id`) BUCKETS 10\nPROPERTIES (\n    "colocate_with" = "group1"\n);\n'))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Create a table with inverted index and bloom filter index"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE example_db.table_hash\n(\n    k1 TINYINT,\n    k2 DECIMAL(10, 2) DEFAULT "10.5",\n    v1 CHAR(10) REPLACE,\n    v2 INT SUM,\n    INDEX k1_idx (k1) USING INVERTED COMMENT\'my first index\'\n)\nAGGREGATE KEY(k1, k2)\nDISTRIBUTED BY HASH(k1) BUCKETS 32\nPROPERTIES (\n    "bloom_filter_columns" = "k2"\n);\n'))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Create a dynamic partition table."),(0,i.yg)("p",{parentName:"li"},"The table creates partitions 3 days in advance every day, and deletes the partitions 3 days ago. For example, if today is ",(0,i.yg)("inlineCode",{parentName:"p"},"2020-01-08"),", partitions named ",(0,i.yg)("inlineCode",{parentName:"p"},"p20200108"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"p20200109"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"p20200110"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"p20200111")," will be created. The partition ranges are:"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},"[types: [DATE]; keys: [2020-01-08]; \u2025types: [DATE]; keys: [2020-01-09];)\n[types: [DATE]; keys: [2020-01-09]; \u2025types: [DATE]; keys: [2020-01-10];)\n[types: [DATE]; keys: [2020-01-10]; \u2025types: [DATE]; keys: [2020-01-11];)\n[types: [DATE]; keys: [2020-01-11]; \u2025types: [DATE]; keys: [2020-01-12];)\n")),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE example_db.dynamic_partition\n(\n    k1 DATE,\n    k2 INT,\n    k3 SMALLINT,\n    v1 VARCHAR(2048),\n    v2 DATETIME DEFAULT "2014-02-04 15:36:00"\n)\nDUPLICATE KEY(k1, k2, k3)\nPARTITION BY RANGE (k1) ()\nDISTRIBUTED BY HASH(k2) BUCKETS 32\nPROPERTIES(\n    "dynamic_partition.time_unit" = "DAY",\n    "dynamic_partition.start" = "-3",\n    "dynamic_partition.end" = "3",\n    "dynamic_partition.prefix" = "p",\n    "dynamic_partition.buckets" = "32"\n);\n'))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Create a table with a materialized view (ROLLUP)."),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE example_db.rolup_index_table\n(\n    event_day DATE,\n    siteid INT DEFAULT '10',\n    citycode SMALLINT,\n    username VARCHAR(32) DEFAULT'',\n    pv BIGINT SUM DEFAULT '0'\n)\nAGGREGATE KEY(event_day, siteid, citycode, username)\nDISTRIBUTED BY HASH(siteid) BUCKETS 10\nROLLUP (\n    r1(event_day,siteid),\n    r2(event_day,citycode),\n    r3(event_day)\n)\nPROPERTIES(\"replication_num\" = \"3\");\n"))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Set the replica of the table through the ",(0,i.yg)("inlineCode",{parentName:"p"},"replication_allocation")," property."),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE example_db.table_hash\n(\n  k1 TINYINT,\n    k2 DECIMAL(10, 2) DEFAULT "10.5"\n)\nDISTRIBUTED BY HASH(k1) BUCKETS 32\nPROPERTIES (\n    "replication_allocation"="tag.location.group_a:1, tag.location.group_b:2"\n);\n')),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE example_db.dynamic_partition\n(\n    k1 DATE,\n    k2 INT,\n    k3 SMALLINT,\n    v1 VARCHAR(2048),\n    v2 DATETIME DEFAULT "2014-02-04 15:36:00"\n)\nPARTITION BY RANGE (k1) ()\nDISTRIBUTED BY HASH(k2) BUCKETS 32\nPROPERTIES(\n    "dynamic_partition.time_unit" = "DAY",\n    "dynamic_partition.start" = "-3",\n    "dynamic_partition.end" = "3",\n    "dynamic_partition.prefix" = "p",\n    "dynamic_partition.buckets" = "32",\n    "dynamic_partition.replication_allocation" = "tag.location.group_a:3"\n );\n'))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Set the table hot and cold separation policy through the ",(0,i.yg)("inlineCode",{parentName:"p"},"storage_policy")," property."),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},'```sql\n    CREATE TABLE IF NOT EXISTS create_table_use_created_policy \n    (\n        k1 BIGINT,\n        k2 LARGEINT,\n        v1 VARCHAR(2048)\n    )\n    UNIQUE KEY(k1)\n    DISTRIBUTED BY HASH (k1) BUCKETS 3\n    PROPERTIES(\n        "storage_policy" = "test_create_table_use_policy",\n        "replication_num" = "1"\n    );\n```\n')),(0,i.yg)("p",{parentName:"li"},"NOTE: Need to create the s3 resource and storage policy before the table can be successfully associated with the migration policy ")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Add a hot and cold data migration strategy for the table partition"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre"},'```sql\n    CREATE TABLE create_table_partion_use_created_policy\n    (\n        k1 DATE,\n        k2 INT,\n        V1 VARCHAR(2048) REPLACE\n    ) PARTITION BY RANGE (k1) (\n        PARTITION p1 VALUES LESS THAN ("2022-01-01") ("storage_policy" = "test_create_table_partition_use_policy_1" ,"replication_num"="1"),\n        PARTITION p2 VALUES LESS THAN ("2022-02-01") ("storage_policy" = "test_create_table_partition_use_policy_2" ,"replication_num"="1")\n    ) DISTRIBUTED BY HASH(k2) BUCKETS 1;\n```\n')),(0,i.yg)("p",{parentName:"li"},"NOTE: Need to create the s3 resource and storage policy before the table can be successfully associated with the migration policy "))),(0,i.yg)("ol",{start:13},(0,i.yg)("li",{parentName:"ol"},"Multi Partition by a partition desc")),(0,i.yg)("admonition",{title:"Tips",type:"tip"},(0,i.yg)("p",{parentName:"admonition"},"This feature is supported since the Apache Doris 1.2 version")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'```sql\n    CREATE TABLE create_table_multi_partion_date\n    (\n        k1 DATE,\n        k2 INT,\n        V1 VARCHAR(20)\n    ) PARTITION BY RANGE (k1) (\n        FROM ("2000-11-14") TO ("2021-11-14") INTERVAL 1 YEAR,\n        FROM ("2021-11-14") TO ("2022-11-14") INTERVAL 1 MONTH,\n        FROM ("2022-11-14") TO ("2023-01-03") INTERVAL 1 WEEK,\n        FROM ("2023-01-03") TO ("2023-01-14") INTERVAL 1 DAY,\n        PARTITION p_20230114 VALUES [(\'2023-01-14\'), (\'2023-01-15\'))\n    ) DISTRIBUTED BY HASH(k2) BUCKETS 1\n    PROPERTIES(\n        "replication_num" = "1"\n    );\n```\n```sql\n    CREATE TABLE create_table_multi_partion_date_hour\n    (\n        k1 DATETIME,\n        k2 INT,\n        V1 VARCHAR(20)\n    ) PARTITION BY RANGE (k1) (\n        FROM ("2023-01-03 12") TO ("2023-01-14 22") INTERVAL 1 HOUR\n    ) DISTRIBUTED BY HASH(k2) BUCKETS 1\n    PROPERTIES(\n        "replication_num" = "1"\n    );\n```\n```sql\n    CREATE TABLE create_table_multi_partion_integer\n    (\n        k1 BIGINT,\n        k2 INT,\n        V1 VARCHAR(20)\n    ) PARTITION BY RANGE (k1) (\n        FROM (1) TO (100) INTERVAL 10\n    ) DISTRIBUTED BY HASH(k2) BUCKETS 1\n    PROPERTIES(\n        "replication_num" = "1"\n    );\n```\n')),(0,i.yg)("p",null,"NOTE: Multi Partition can be mixed with conventional manual creation of partitions. When using, you need to limit the partition column to only one, The default maximum number of partitions created in multi partition is 4096, This parameter can be adjusted in fe configuration ",(0,i.yg)("inlineCode",{parentName:"p"},"max_multi_partition_num"),"."),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Add a duplicate without sorting column table"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE example_db.table_hash\n(\n    k1 DATE,\n    k2 DECIMAL(10, 2) DEFAULT "10.5",\n    k3 CHAR(10) COMMENT "string column",\n    k4 INT NOT NULL DEFAULT "1" COMMENT "int column"\n)\nCOMMENT "duplicate without keys"\nPARTITION BY RANGE(k1)\n(\n    PARTITION p1 VALUES LESS THAN ("2020-02-01"),\n    PARTITION p2 VALUES LESS THAN ("2020-03-01"),\n    PARTITION p3 VALUES LESS THAN ("2020-04-01")\n)\nDISTRIBUTED BY HASH(k1) BUCKETS 32\nPROPERTIES (\n    "replication_num" = "1",\n    "enable_duplicate_without_keys_by_default" = "true"\n);\n')))),(0,i.yg)("h3",{id:"keywords"},"Keywords"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"CREATE, TABLE\n")),(0,i.yg)("h3",{id:"best-practice"},"Best Practice"),(0,i.yg)("h4",{id:"partitioning-and-bucketing"},"Partitioning and bucketing"),(0,i.yg)("p",null,"A table must specify the bucket column, but it does not need to specify the partition. For the specific introduction of partitioning and bucketing, please refer to the ",(0,i.yg)("a",{parentName:"p",href:"../../../../table-design/data-partitioning/basic-concepts"},"Data Partitioning")," document."),(0,i.yg)("p",null,"Tables in Doris can be divided into partitioned tables and non-partitioned tables. This attribute is determined when the table is created and cannot be changed afterwards. That is, for partitioned tables, you can add or delete partitions in the subsequent use process, and for non-partitioned tables, you can no longer perform operations such as adding partitions afterwards."),(0,i.yg)("p",null,"At the same time, partitioning columns and bucketing columns cannot be changed after the table is created. You can neither change the types of partitioning and bucketing columns, nor do any additions or deletions to these columns."),(0,i.yg)("p",null,"Therefore, it is recommended to confirm the usage method to build the table reasonably before building the table."),(0,i.yg)("h4",{id:"dynamic-partition"},"Dynamic Partition"),(0,i.yg)("p",null,"The dynamic partition function is mainly used to help users automatically manage partitions. By setting certain rules, the Doris system regularly adds new partitions or deletes historical partitions. Please refer to ",(0,i.yg)("a",{parentName:"p",href:"../../../../table-design/data-partitioning/dynamic-partitioning"},"Dynamic Partition")," document for more help."),(0,i.yg)("h4",{id:"auto-partition"},"Auto Partition"),(0,i.yg)("p",null,"See the ",(0,i.yg)("a",{parentName:"p",href:"../../../../table-design/data-partitioning/auto-partitioning"},"Auto Partition")," document."),(0,i.yg)("h4",{id:"materialized-view"},"Materialized View"),(0,i.yg)("p",null,"Users can create multiple materialized views (ROLLUP) while building a table. Materialized views can also be added after the table is built. It is convenient for users to create all materialized views at one time by writing in the table creation statement."),(0,i.yg)("p",null,"If the materialized view is created when the table is created, all subsequent data import operations will synchronize the data of the materialized view to be generated. The number of materialized views may affect the efficiency of data import."),(0,i.yg)("p",null,"If you add a materialized view in the subsequent use process, if there is data in the table, the creation time of the materialized view depends on the current amount of data."),(0,i.yg)("p",null,"For the introduction of materialized views, please refer to the ",(0,i.yg)("a",{parentName:"p",href:"../../../../query/view-materialized-view/metarialized-view"},"Materialized View")," document."),(0,i.yg)("h4",{id:"index"},"Index"),(0,i.yg)("p",null,"Users can create indexes on multiple columns while building a table. Indexes can also be added after the table is built."),(0,i.yg)("p",null,"If you add an index in the subsequent use process, if there is data in the table, you need to rewrite all the data, so the creation time of the index depends on the current data volume."))}c.isMDXComponent=!0}}]);