"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([[517784],{15680:(e,t,a)=>{a.d(t,{xA:()=>m,yg:()=>h});var i=a(296540);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function n(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,i)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?n(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):n(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,i,r=function(e,t){if(null==e)return{};var a,i,r={},n=Object.keys(e);for(i=0;i<n.length;i++)a=n[i],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(i=0;i<n.length;i++)a=n[i],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=i.createContext({}),d=function(e){var t=i.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},m=function(e){var t=d(e.components);return i.createElement(o.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},p=i.forwardRef((function(e,t){var a=e.components,r=e.mdxType,n=e.originalType,o=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),u=d(a),p=r,h=u["".concat(o,".").concat(p)]||u[p]||c[p]||n;return a?i.createElement(h,l(l({ref:t},m),{},{components:a})):i.createElement(h,l({ref:t},m))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var n=a.length,l=new Array(n);l[0]=p;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[u]="string"==typeof e?e:r,l[1]=s;for(var d=2;d<n;d++)l[d]=a[d];return i.createElement.apply(null,l)}return i.createElement.apply(null,a)}p.displayName="MDXCreateElement"},519722:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>n,metadata:()=>s,toc:()=>d});var i=a(58168),r=(a(296540),a(15680));const n={title:"Materialized View",language:"en"},l=void 0,s={unversionedId:"query/view-materialized-view/materialized-view",id:"version-2.0/query/view-materialized-view/materialized-view",title:"Materialized View",description:"\x3c!--",source:"@site/versioned_docs/version-2.0/query/view-materialized-view/materialized-view.md",sourceDirName:"query/view-materialized-view",slug:"/query/view-materialized-view/materialized-view",permalink:"/docs/2.0/query/view-materialized-view/materialized-view",draft:!1,tags:[],version:"2.0",frontMatter:{title:"Materialized View",language:"en"},sidebar:"docs",previous:{title:"View",permalink:"/docs/2.0/query/view-materialized-view/create-view"},next:{title:"Doris Join Optimization Principle",permalink:"/docs/2.0/query/join-optimization/doris-join-optimization"}},o={},d=[{value:"When to use materialized view",id:"when-to-use-materialized-view",level:2},{value:"Advantage",id:"advantage",level:2},{value:"Materialized View VS Rollup",id:"materialized-view-vs-rollup",level:2},{value:"Use materialized views",id:"use-materialized-views",level:2},{value:"Create a materialized view",id:"create-a-materialized-view",level:3},{value:"Support aggregate functions",id:"support-aggregate-functions",level:3},{value:"Update strategy",id:"update-strategy",level:3},{value:"Query automatic matching",id:"query-automatic-matching",level:3},{value:"Query materialized views",id:"query-materialized-views",level:3},{value:"Delete materialized view",id:"delete-materialized-view",level:3},{value:"View the materialized view that has been created",id:"view-the-materialized-view-that-has-been-created",level:3},{value:"Cancel Create materialized view",id:"cancel-create-materialized-view",level:3},{value:"Best Practice 1",id:"best-practice-1",level:2},{value:"Best Practice 2 PV,UV",id:"best-practice-2-pvuv",level:2},{value:"Best Practice 3",id:"best-practice-3",level:2},{value:"Best Practice 4",id:"best-practice-4",level:2},{value:"Limitations",id:"limitations",level:2},{value:"Error",id:"error",level:2},{value:"More Help",id:"more-help",level:2}],m={toc:d},u="wrapper";function c(e){let{components:t,...a}=e;return(0,r.yg)(u,(0,i.A)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"materialized-view"},"Materialized View"),(0,r.yg)("p",null,"A materialized view is a data set that is pre-calculated (according to a defined SELECT statement) and stored in a special table in Doris."),(0,r.yg)("p",null,"The emergence of materialized views is mainly to satisfy users. It can analyze any dimension of the original detailed data, but also can quickly analyze and query fixed dimensions."),(0,r.yg)("h2",{id:"when-to-use-materialized-view"},"When to use materialized view"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Analyze requirements to cover both detailed data query and fixed-dimensional query."),(0,r.yg)("li",{parentName:"ul"},"The query only involves a small part of the columns or rows in the table."),(0,r.yg)("li",{parentName:"ul"},"The query contains some time-consuming processing operations, such as long-time aggregation operations."),(0,r.yg)("li",{parentName:"ul"},"The query needs to match different prefix indexes.")),(0,r.yg)("h2",{id:"advantage"},"Advantage"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"For those queries that frequently use the same sub-query results repeatedly, the performance is greatly improved"),(0,r.yg)("li",{parentName:"ul"},"Doris automatically maintains the data of the materialized view, whether it is a new import or delete operation, it can ensure the data consistency of the base table and the materialized view table. No need for any additional labor maintenance costs."),(0,r.yg)("li",{parentName:"ul"},"When querying, it will automatically match the optimal materialized view and read data directly from the materialized view.")),(0,r.yg)("p",null,(0,r.yg)("em",{parentName:"p"},"Automatic maintenance of materialized view data will cause some maintenance overhead, which will be explained in the limitations of materialized views later.")),(0,r.yg)("h2",{id:"materialized-view-vs-rollup"},"Materialized View VS Rollup"),(0,r.yg)("p",null,"Before the materialized view function, users generally used the Rollup function to improve query efficiency through pre-aggregation. However, Rollup has certain limitations. It cannot do pre-aggregation based on the detailed model."),(0,r.yg)("p",null,"Materialized views cover the functions of Rollup while also supporting richer aggregate functions. So the materialized view is actually a superset of Rollup."),(0,r.yg)("p",null,"In other words, the functions previously supported by the ",(0,r.yg)("inlineCode",{parentName:"p"},"ALTER TABLE ADD ROLLUP")," syntax can now be implemented by ",(0,r.yg)("inlineCode",{parentName:"p"},"CREATE MATERIALIZED VIEW"),"."),(0,r.yg)("h2",{id:"use-materialized-views"},"Use materialized views"),(0,r.yg)("p",null,"The Doris system provides a complete set of DDL syntax for materialized views, including creating, viewing, and deleting. The syntax of DDL is consistent with PostgreSQL and Oracle."),(0,r.yg)("h3",{id:"create-a-materialized-view"},"Create a materialized view"),(0,r.yg)("p",null,"Here you must first decide what kind of materialized view to create based on the characteristics of your query statement. This is not to say that your materialized view definition is exactly the same as one of your query statements. There are two principles here:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Abstract")," from the query statement, the grouping and aggregation methods shared by multiple queries are used as the definition of the materialized view."),(0,r.yg)("li",{parentName:"ol"},"It is not necessary to create materialized views for all dimension combinations.")),(0,r.yg)("p",null,"First of all, the first point, if a materialized view is abstracted, and multiple queries can be matched to this materialized view. This materialized view works best. Because the maintenance of the materialized view itself also consumes resources."),(0,r.yg)("p",null,"If the materialized view only fits a particular query, and other queries do not use this materialized view. As a result, the materialized view is not cost-effective, which not only occupies the storage resources of the cluster, but cannot serve more queries."),(0,r.yg)("p",null,"Therefore, users need to combine their own query statements and data dimension information to abstract the definition of some materialized views."),(0,r.yg)("p",null,"The second point is that in the actual analysis query, not all dimensional analysis will be covered. Therefore, it is enough to create a materialized view for the commonly used combination of dimensions, so as to achieve a space and time balance."),(0,r.yg)("p",null,"Creating a materialized view is an asynchronous operation, which means that after the user successfully submits the creation task, Doris will calculate the existing data in the background until the creation is successful."),(0,r.yg)("p",null,"The specific syntax can be viewed through the following command:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"HELP CREATE MATERIALIZED VIEW\n")),(0,r.yg)("admonition",{title:"Tips",type:"tip"},(0,r.yg)("p",{parentName:"admonition"},"This feature is supported since the Apache Doris 2.0 version")),(0,r.yg)("p",null,"In ",(0,r.yg)("inlineCode",{parentName:"p"},"Doris 2.0")," we made some enhancements to materialized views (described in ",(0,r.yg)("inlineCode",{parentName:"p"},"Best Practice 4")," of this article). We recommend that users check whether the expected query can hit the desired materialized view in the test environment before using the materialized view in the official production environment."),(0,r.yg)("p",null,"If you don't know how to verify that a query hits a materialized view, you can read ",(0,r.yg)("inlineCode",{parentName:"p"},"Best Practice 1")," of this article."),(0,r.yg)("p",null,"At the same time, we do not recommend that users create multiple materialized views with similar shapes on the same table, which may cause conflicts between multiple materialized views and cause query hit failures (this problem will be improved in the new optimizer ). It is recommended that users first verify whether materialized views and queries meet the requirements and can be used normally in the test environment."),(0,r.yg)("h3",{id:"support-aggregate-functions"},"Support aggregate functions"),(0,r.yg)("p",null,"The aggregate functions currently supported by the materialized view function are:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"SUM, MIN, MAX (Version 0.12)"),(0,r.yg)("li",{parentName:"ul"},"COUNT, BITMAP","_","UNION, HLL","_","UNION (Version 0.13)")),(0,r.yg)("h3",{id:"update-strategy"},"Update strategy"),(0,r.yg)("p",null,"In order to ensure the data consistency between the materialized view table and the Base table, Doris will import, delete and other operations on the Base table are synchronized to the materialized view table. And through incremental update to improve update efficiency. To ensure atomicity through transaction."),(0,r.yg)("p",null,"For example, if the user inserts data into the base table through the INSERT command, this data will be inserted into the materialized view synchronously. When both the base table and the materialized view table are written successfully, the INSERT command will return successfully."),(0,r.yg)("h3",{id:"query-automatic-matching"},"Query automatic matching"),(0,r.yg)("p",null,"After the materialized view is successfully created, the user's query does not need to be changed, that is, it is still the base table of the query. Doris will automatically select an optimal materialized view based on the current query statement, read data from the materialized view and calculate it."),(0,r.yg)("p",null,"Users can use the EXPLAIN command to check whether the current query uses a materialized view."),(0,r.yg)("p",null,"The matching relationship between the aggregation in the materialized view and the aggregation in the query:"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Materialized View Aggregation"),(0,r.yg)("th",{parentName:"tr",align:null},"Query Aggregation"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"sum"),(0,r.yg)("td",{parentName:"tr",align:null},"sum")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"min"),(0,r.yg)("td",{parentName:"tr",align:null},"min")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"max"),(0,r.yg)("td",{parentName:"tr",align:null},"max")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"count"),(0,r.yg)("td",{parentName:"tr",align:null},"count")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"bitmap","_","union"),(0,r.yg)("td",{parentName:"tr",align:null},"bitmap","_","union, bitmap","_","union","_","count, count(distinct)")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"hll","_","union"),(0,r.yg)("td",{parentName:"tr",align:null},"hll","_","raw","_","agg, hll","_","union","_","agg, ndv, approx","_","count","_","distinct")))),(0,r.yg)("p",null,"After the aggregation functions of bitmap and hll match the materialized view in the query, the aggregation operator of the query will be rewritten according to the table structure of the materialized view. See example 2 for details."),(0,r.yg)("h3",{id:"query-materialized-views"},"Query materialized views"),(0,r.yg)("p",null,"Check what materialized views the current table has, and what their table structure is. Through the following command:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"MySQL [test]> desc mv_test all;\n+-----------+---------------+-----------------+----------+------+-------+---------+--------------+\n| IndexName | IndexKeysType | Field           | Type     | Null | Key   | Default | Extra        |\n+-----------+---------------+-----------------+----------+------+-------+---------+--------------+\n| mv_test   | DUP_KEYS      | k1              | INT      | Yes  | true  | NULL    |              |\n|           |               | k2              | BIGINT   | Yes  | true  | NULL    |              |\n|           |               | k3              | LARGEINT | Yes  | true  | NULL    |              |\n|           |               | k4              | SMALLINT | Yes  | false | NULL    | NONE         |\n|           |               |                 |          |      |       |         |              |\n| mv_2      | AGG_KEYS      | k2              | BIGINT   | Yes  | true  | NULL    |              |\n|           |               | k4              | SMALLINT | Yes  | false | NULL    | MIN          |\n|           |               | k1              | INT      | Yes  | false | NULL    | MAX          |\n|           |               |                 |          |      |       |         |              |\n| mv_3      | AGG_KEYS      | k1              | INT      | Yes  | true  | NULL    |              |\n|           |               | to_bitmap(`k2`) | BITMAP   | No   | false |         | BITMAP_UNION |\n|           |               |                 |          |      |       |         |              |\n| mv_1      | AGG_KEYS      | k4              | SMALLINT | Yes  | true  | NULL    |              |\n|           |               | k1              | BIGINT   | Yes  | false | NULL    | SUM          |\n|           |               | k3              | LARGEINT | Yes  | false | NULL    | SUM          |\n|           |               | k2              | BIGINT   | Yes  | false | NULL    | MIN          |\n+-----------+---------------+-----------------+----------+------+-------+---------+--------------+\n")),(0,r.yg)("p",null,"You can see that the current ",(0,r.yg)("inlineCode",{parentName:"p"},"mv_test")," table has three materialized views: mv","_","1, mv","_","2 and mv","_","3, and their table structure."),(0,r.yg)("h3",{id:"delete-materialized-view"},"Delete materialized view"),(0,r.yg)("p",null,"If the user no longer needs the materialized view, you can delete the materialized view by 'DROP' commen."),(0,r.yg)("p",null,"You can view the specific syntax",(0,r.yg)("a",{parentName:"p",href:"../../sql-manual/sql-reference/Data-Definition-Statements/Drop/DROP-MATERIALIZED-VIEW"},"SHOW CREATE MATERIALIZED VIEW")),(0,r.yg)("h3",{id:"view-the-materialized-view-that-has-been-created"},"View the materialized view that has been created"),(0,r.yg)("p",null,"Users can view the created materialized views by using commands"),(0,r.yg)("p",null,"You can view the specific syntax",(0,r.yg)("a",{parentName:"p",href:"../../sql-manual/sql-reference/Show-Statements/SHOW-CREATE-MATERIALIZED-VIEW"},"SHOW CREATE MATERIALIZED VIEW")),(0,r.yg)("h3",{id:"cancel-create-materialized-view"},"Cancel Create materialized view"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-text"},"CANCEL ALTER TABLE MATERIALIZED VIEW FROM db_name.table_name\n")),(0,r.yg)("h2",{id:"best-practice-1"},"Best Practice 1"),(0,r.yg)("p",null,"The use of materialized views is generally divided into the following steps:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"Create a materialized view"),(0,r.yg)("li",{parentName:"ol"},"Asynchronously check whether the materialized view has been constructed"),(0,r.yg)("li",{parentName:"ol"},"Query and automatically match materialized views")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"First is the first step: Create a materialized view")),(0,r.yg)("p",null,"Assume that the user has a sales record list, which stores the transaction id, salesperson, sales store, sales time, and amount of each transaction. The table building statement and insert data statement is:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},'create table sales_records(record_id int, seller_id int, store_id int, sale_date date, sale_amt bigint) distributed by hash(record_id) properties("replication_num" = "1");\ninsert into sales_records values(1,1,1,"2020-02-02",1);\n')),(0,r.yg)("p",null,"The table structure of this ",(0,r.yg)("inlineCode",{parentName:"p"},"sales_records")," is as follows:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"MySQL [test]> desc sales_records;\n+-----------+--------+------+-------+---------+--- ----+\n| Field | Type | Null | Key | Default | Extra |\n+-----------+--------+------+-------+---------+--- ----+\n| record_id | INT | Yes | true | NULL | |\n| seller_id | INT | Yes | true | NULL | |\n| store_id | INT | Yes | true | NULL | |\n| sale_date | DATE | Yes | false | NULL | NONE |\n| sale_amt | BIGINT | Yes | false | NULL | NONE |\n+-----------+--------+------+-------+---------+--- ----+\n")),(0,r.yg)("p",null,"At this time, if the user often performs an analysis query on the sales volume of different stores, you can create a materialized view for the ",(0,r.yg)("inlineCode",{parentName:"p"},"sales_records")," table to group the sales stores and sum the sales of the same sales stores. The creation statement is as follows:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"MySQL [test]> create materialized view store_amt as select store_id, sum(sale_amt) from sales_records group by store_id;\n")),(0,r.yg)("p",null,"The backend returns to the following figure, indicating that the task of creating a materialized view is submitted successfully."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"Query OK, 0 rows affected (0.012 sec)\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Step 2: Check whether the materialized view has been built")),(0,r.yg)("p",null,"Since the creation of a materialized view is an asynchronous operation, after the user submits the task of creating a materialized view, he needs to asynchronously check whether the materialized view has been constructed through a command. The command is as follows:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"SHOW ALTER TABLE ROLLUP FROM db_name; (Version 0.12)\nSHOW ALTER TABLE MATERIALIZED VIEW FROM db_name; (Version 0.13)\n")),(0,r.yg)("p",null,"In this command, ",(0,r.yg)("inlineCode",{parentName:"p"},"db_name")," is a parameter, you need to replace it with your real db name. The result of the command is to display all the tasks of creating a materialized view of this db. The results are as follows:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"+-------+---------------+---------------------+--- ------------------+---------------+--------------- --+----------+---------------+-----------+-------- -------------------------------------------------- -------------------------------------------------- -------------+----------+---------+\n| JobId | TableName | CreateTime | FinishedTime | BaseIndexName | RollupIndexName | RollupId | TransactionId | State | Msg | Progress | Timeout |\n+-------+---------------+---------------------+--- ------------------+---------------+--------------- --+----------+---------------+-----------+-------- -------------------------------------------------- -------------------------------------------------- -------------+----------+---------+\n| 22036 | sales_records | 2020-07-30 20:04:28 | 2020-07-30 20:04:57 | sales_records | store_amt | 22037 | 5008 | FINISHED | | NULL | 86400 |\n+-------+---------------+---------------------+--- ------------------+---------------+--------------- --+----------+---------------+-----------+-------- ----------------------------------------\n\n")),(0,r.yg)("p",null,"Among them, TableName refers to which table the data of the materialized view comes from, and RollupIndexName refers to the name of the materialized view. One of the more important indicators is State."),(0,r.yg)("p",null,"When the State of the task of creating a materialized view has become FINISHED, it means that the materialized view has been created successfully. This means that it is possible to automatically match this materialized view when querying."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Step 3: Query")),(0,r.yg)("p",null,"After the materialized view is created, when users query the sales volume of different stores, they will directly read the aggregated data from the materialized view ",(0,r.yg)("inlineCode",{parentName:"p"},"store_amt")," just created. To achieve the effect of improving query efficiency."),(0,r.yg)("p",null,"The user's query still specifies the query ",(0,r.yg)("inlineCode",{parentName:"p"},"sales_records")," table, for example:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"SELECT store_id, sum(sale_amt) FROM sales_records GROUP BY store_id;\n")),(0,r.yg)("p",null,"The above query will automatically match ",(0,r.yg)("inlineCode",{parentName:"p"},"store_amt"),". The user can use the following command to check whether the current query matches the appropriate materialized view."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"EXPLAIN SELECT store_id, sum(sale_amt) FROM sales_records GROUP BY store_id;\n+----------------------------------------------------------------------------------------------+\n| Explain String                                                                               |\n+----------------------------------------------------------------------------------------------+\n| PLAN FRAGMENT 0                                                                              |\n|   OUTPUT EXPRS:                                                                              |\n|     <slot 4> `default_cluster:test`.`sales_records`.`mv_store_id`                            |\n|     <slot 5> sum(`default_cluster:test`.`sales_records`.`mva_SUM__`sale_amt``)               |\n|   PARTITION: UNPARTITIONED                                                                   |\n|                                                                                              |\n|   VRESULT SINK                                                                               |\n|                                                                                              |\n|   4:VEXCHANGE                                                                                |\n|      offset: 0                                                                               |\n|                                                                                              |\n| PLAN FRAGMENT 1                                                                              |\n|                                                                                              |\n|   PARTITION: HASH_PARTITIONED: <slot 4> `default_cluster:test`.`sales_records`.`mv_store_id` |\n|                                                                                              |\n|   STREAM DATA SINK                                                                           |\n|     EXCHANGE ID: 04                                                                          |\n|     UNPARTITIONED                                                                            |\n|                                                                                              |\n|   3:VAGGREGATE (merge finalize)                                                              |\n|   |  output: sum(<slot 5> sum(`default_cluster:test`.`sales_records`.`mva_SUM__`sale_amt``)) |\n|   |  group by: <slot 4> `default_cluster:test`.`sales_records`.`mv_store_id`                 |\n|   |  cardinality=-1                                                                          |\n|   |                                                                                          |\n|   2:VEXCHANGE                                                                                |\n|      offset: 0                                                                               |\n|                                                                                              |\n| PLAN FRAGMENT 2                                                                              |\n|                                                                                              |\n|   PARTITION: HASH_PARTITIONED: `default_cluster:test`.`sales_records`.`record_id`            |\n|                                                                                              |\n|   STREAM DATA SINK                                                                           |\n|     EXCHANGE ID: 02                                                                          |\n|     HASH_PARTITIONED: <slot 4> `default_cluster:test`.`sales_records`.`mv_store_id`          |\n|                                                                                              |\n|   1:VAGGREGATE (update serialize)                                                            |\n|   |  STREAMING                                                                               |\n|   |  output: sum(`default_cluster:test`.`sales_records`.`mva_SUM__`sale_amt``)               |\n|   |  group by: `default_cluster:test`.`sales_records`.`mv_store_id`                          |\n|   |  cardinality=-1                                                                          |\n|   |                                                                                          |\n|   0:VOlapScanNode                                                                            |\n|      TABLE: default_cluster:test.sales_records(store_amt), PREAGGREGATION: ON                |\n|      partitions=1/1, tablets=10/10, tabletList=50028,50030,50032 ...                         |\n|      cardinality=1, avgRowSize=1520.0, numNodes=1                                            |\n+----------------------------------------------------------------------------------------------+\n")),(0,r.yg)("p",null,"From the bottom ",(0,r.yg)("inlineCode",{parentName:"p"},"test.sales_records(store_amt)"),", it can be shown that this query hits the ",(0,r.yg)("inlineCode",{parentName:"p"},"store_amt")," materialized view. It is worth noting that if there is no data in the table, then the materialized view may not be hit."),(0,r.yg)("h2",{id:"best-practice-2-pvuv"},"Best Practice 2 PV,UV"),(0,r.yg)("p",null,"Business scenario: Calculate the UV and PV of advertising"),(0,r.yg)("p",null,"Assuming that the user's original ad click data is stored in Doris, then for ad PV and UV queries, the query speed can be improved by creating a materialized view of ",(0,r.yg)("inlineCode",{parentName:"p"},"bitmap_union"),"."),(0,r.yg)("p",null,"Use the following statement to first create a table that stores the details of the advertisement click data, including the click event of each click, what advertisement was clicked, what channel clicked, and who was the user who clicked."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},'MySQL [test]> create table advertiser_view_record(time date, advertiser varchar(10), channel varchar(10), user_id int) distributed by hash(time) properties("replication_num" = "1");\ninsert into advertiser_view_record values("2020-02-02",\'a\',\'a\',1);\n')),(0,r.yg)("p",null,"The original ad click data table structure is:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"MySQL [test]> desc advertiser_view_record;\n+------------+-------------+------+-------+---------+-------+\n| Field      | Type        | Null | Key   | Default | Extra |\n+------------+-------------+------+-------+---------+-------+\n| time       | DATE        | Yes  | true  | NULL    |       |\n| advertiser | VARCHAR(10) | Yes  | true  | NULL    |       |\n| channel    | VARCHAR(10) | Yes  | false | NULL    | NONE  |\n| user_id    | INT         | Yes  | false | NULL    | NONE  |\n+------------+-------------+------+-------+---------+-------+\n4 rows in set (0.001 sec)\n")),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Create a materialized view"),(0,r.yg)("p",{parentName:"li"},"Since the user wants to query the UV value of the advertisement, that is, a precise de-duplication of users of the same advertisement is required, the user's query is generally:"),(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre"},"SELECT advertiser, channel, count(distinct user_id) FROM advertiser_view_record GROUP BY advertiser, channel;\n")),(0,r.yg)("p",{parentName:"li"},"For this kind of UV-seeking scene, we can create a materialized view with ",(0,r.yg)("inlineCode",{parentName:"p"},"bitmap_union")," to achieve a precise deduplication effect in advance."),(0,r.yg)("p",{parentName:"li"},"In Doris, the result of ",(0,r.yg)("inlineCode",{parentName:"p"},"count(distinct)")," aggregation is exactly the same as the result of ",(0,r.yg)("inlineCode",{parentName:"p"},"bitmap_union_count")," aggregation. And ",(0,r.yg)("inlineCode",{parentName:"p"},"bitmap_union_count")," is equal to the result of ",(0,r.yg)("inlineCode",{parentName:"p"},"bitmap_union")," to calculate count, so if the query ",(0,r.yg)("strong",{parentName:"p"}," involves ",(0,r.yg)("inlineCode",{parentName:"strong"},"count(distinct)"),", you can speed up the query by creating a materialized view with ",(0,r.yg)("inlineCode",{parentName:"strong"},"bitmap_union")," aggregation.")),(0,r.yg)("p",{parentName:"li"},"For this case, you can create a materialized view that accurately deduplicate ",(0,r.yg)("inlineCode",{parentName:"p"},"user_id")," based on advertising and channel grouping."),(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre"},"MySQL [test]> create materialized view advertiser_uv as select advertiser, channel, bitmap_union(to_bitmap(user_id)) from advertiser_view_record group by advertiser, channel;\nQuery OK, 0 rows affected (0.012 sec)\n")),(0,r.yg)("p",{parentName:"li"},(0,r.yg)("em",{parentName:"p"},"Note: Because the user","_","id itself is an INT type, it is called ",(0,r.yg)("inlineCode",{parentName:"em"},"bitmap_union")," directly in Doris. The fields need to be converted to bitmap type through the function ",(0,r.yg)("inlineCode",{parentName:"em"},"to_bitmap")," first, and then ",(0,r.yg)("inlineCode",{parentName:"em"},"bitmap_union")," can be aggregated. ")),(0,r.yg)("p",{parentName:"li"},"After the creation is complete, the table structure of the advertisement click schedule and the materialized view table is as follows:"),(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre"},"MySQL [test]> desc advertiser_view_record all;\n+------------------------+---------------+----------------------+-------------+------+-------+---------+--------------+\n| IndexName              | IndexKeysType | Field                | Type        | Null | Key   | Default | Extra        |\n+------------------------+---------------+----------------------+-------------+------+-------+---------+--------------+\n| advertiser_view_record | DUP_KEYS      | time                 | DATE        | Yes  | true  | NULL    |              |\n|                        |               | advertiser           | VARCHAR(10) | Yes  | true  | NULL    |              |\n|                        |               | channel              | VARCHAR(10) | Yes  | false | NULL    | NONE         |\n|                        |               | user_id              | INT         | Yes  | false | NULL    | NONE         |\n|                        |               |                      |             |      |       |         |              |\n| advertiser_uv          | AGG_KEYS      | advertiser           | VARCHAR(10) | Yes  | true  | NULL    |              |\n|                        |               | channel              | VARCHAR(10) | Yes  | true  | NULL    |              |\n|                        |               | to_bitmap(`user_id`) | BITMAP      | No   | false |         | BITMAP_UNION |\n+------------------------+---------------+----------------------+-------------+------+-------+---------+--------------+\n"))),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Automatic query matching"),(0,r.yg)("p",{parentName:"li"},"When the materialized view table is created, when querying the advertisement UV, Doris will automatically query the data from the materialized view ",(0,r.yg)("inlineCode",{parentName:"p"},"advertiser_uv")," just created. For example, the original query statement is as follows:"),(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre"},"SELECT advertiser, channel, count(distinct user_id) FROM advertiser_view_record GROUP BY advertiser, channel;\n")),(0,r.yg)("p",{parentName:"li"},"After the materialized view is selected, the actual query will be transformed into:"),(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre"},"SELECT advertiser, channel, bitmap_union_count(to_bitmap(user_id)) FROM advertiser_uv GROUP BY advertiser, channel;\n")),(0,r.yg)("p",{parentName:"li"},"Through the EXPLAIN command, you can check whether Doris matches the materialized view:"),(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"mysql [test]>explain SELECT advertiser, channel, count(distinct user_id) FROM  advertiser_view_record GROUP BY advertiser, channel;\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| Explain String                                                                                                                                                                 |\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n| PLAN FRAGMENT 0                                                                                                                                                                |\n|   OUTPUT EXPRS:                                                                                                                                                                |\n|     <slot 9> `default_cluster:test`.`advertiser_view_record`.`mv_advertiser`                                                                                                   |\n|     <slot 10> `default_cluster:test`.`advertiser_view_record`.`mv_channel`                                                                                                     |\n|     <slot 11> bitmap_union_count(`default_cluster:test`.`advertiser_view_record`.`mva_BITMAP_UNION__to_bitmap_with_check(`user_id`)`)                                          |\n|   PARTITION: UNPARTITIONED                                                                                                                                                     |\n|                                                                                                                                                                                |\n|   VRESULT SINK                                                                                                                                                                 |\n|                                                                                                                                                                                |\n|   4:VEXCHANGE                                                                                                                                                                  |\n|      offset: 0                                                                                                                                                                 |\n|                                                                                                                                                                                |\n| PLAN FRAGMENT 1                                                                                                                                                                |\n|                                                                                                                                                                                |\n|   PARTITION: HASH_PARTITIONED: <slot 6> `default_cluster:test`.`advertiser_view_record`.`mv_advertiser`, <slot 7> `default_cluster:test`.`advertiser_view_record`.`mv_channel` |\n|                                                                                                                                                                                |\n|   STREAM DATA SINK                                                                                                                                                             |\n|     EXCHANGE ID: 04                                                                                                                                                            |\n|     UNPARTITIONED                                                                                                                                                              |\n|                                                                                                                                                                                |\n|   3:VAGGREGATE (merge finalize)                                                                                                                                                |\n|   |  output: bitmap_union_count(<slot 8> bitmap_union_count(`default_cluster:test`.`advertiser_view_record`.`mva_BITMAP_UNION__to_bitmap_with_check(`user_id`)`))              |\n|   |  group by: <slot 6> `default_cluster:test`.`advertiser_view_record`.`mv_advertiser`, <slot 7> `default_cluster:test`.`advertiser_view_record`.`mv_channel`                 |\n|   |  cardinality=-1                                                                                                                                                            |\n|   |                                                                                                                                                                            |\n|   2:VEXCHANGE                                                                                                                                                                  |\n|      offset: 0                                                                                                                                                                 |\n|                                                                                                                                                                                |\n| PLAN FRAGMENT 2                                                                                                                                                                |\n|                                                                                                                                                                                |\n|   PARTITION: HASH_PARTITIONED: `default_cluster:test`.`advertiser_view_record`.`time`                                                                                          |\n|                                                                                                                                                                                |\n|   STREAM DATA SINK                                                                                                                                                             |\n|     EXCHANGE ID: 02                                                                                                                                                            |\n|     HASH_PARTITIONED: <slot 6> `default_cluster:test`.`advertiser_view_record`.`mv_advertiser`, <slot 7> `default_cluster:test`.`advertiser_view_record`.`mv_channel`          |\n|                                                                                                                                                                                |\n|   1:VAGGREGATE (update serialize)                                                                                                                                              |\n|   |  STREAMING                                                                                                                                                                 |\n|   |  output: bitmap_union_count(`default_cluster:test`.`advertiser_view_record`.`mva_BITMAP_UNION__to_bitmap_with_check(`user_id`)`)                                           |\n|   |  group by: `default_cluster:test`.`advertiser_view_record`.`mv_advertiser`, `default_cluster:test`.`advertiser_view_record`.`mv_channel`                                   |\n|   |  cardinality=-1                                                                                                                                                            |\n|   |                                                                                                                                                                            |\n|   0:VOlapScanNode                                                                                                                                                              |\n|      TABLE: default_cluster:test.advertiser_view_record(advertiser_uv), PREAGGREGATION: ON                                                                                     |\n|      partitions=1/1, tablets=10/10, tabletList=50075,50077,50079 ...                                                                                                           |\n|      cardinality=0, avgRowSize=48.0, numNodes=1                                                                                                                                |\n+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+\n")),(0,r.yg)("p",{parentName:"li"},"In the result of EXPLAIN, you can first see that ",(0,r.yg)("inlineCode",{parentName:"p"},"VOlapScanNode")," hits ",(0,r.yg)("inlineCode",{parentName:"p"},"advertiser_uv"),". That is, the query scans the materialized view's data directly. Indicates that the match is successful."),(0,r.yg)("p",{parentName:"li"},"Secondly, the calculation of ",(0,r.yg)("inlineCode",{parentName:"p"},"count(distinct)")," for the ",(0,r.yg)("inlineCode",{parentName:"p"},"user_id")," field is rewritten as ",(0,r.yg)("inlineCode",{parentName:"p"},"bitmap_union_count"),". That is to achieve the effect of precise deduplication through bitmap."))),(0,r.yg)("h2",{id:"best-practice-3"},"Best Practice 3"),(0,r.yg)("p",null,"Business scenario: matching a richer prefix index"),(0,r.yg)("p",null,"The user's original table has three columns (k1, k2, k3). Among them, k1, k2 are prefix index columns. At this time, if the user query condition contains ",(0,r.yg)("inlineCode",{parentName:"p"},"where k1=a and k2=b"),", the query can be accelerated through the index."),(0,r.yg)("p",null,"But in some cases, the user's filter conditions cannot match the prefix index, such as ",(0,r.yg)("inlineCode",{parentName:"p"},"where k3=c"),". Then the query speed cannot be improved through the index."),(0,r.yg)("p",null,"This problem can be solved by creating a materialized view with k3 as the first column."),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Create a materialized view"),(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre"},"CREATE MATERIALIZED VIEW mv_1 as SELECT k3, k2, k1 FROM tableA ORDER BY k3;\n")),(0,r.yg)("p",{parentName:"li"},"After the creation of the above grammar is completed, the complete detail data is retained in the materialized view, and the prefix index of the materialized view is the k3 column. The table structure is as follows:"),(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre"},"MySQL [test]> desc tableA all;\n+-----------+---------------+-------+------+------+-------+---------+-------+\n| IndexName | IndexKeysType | Field | Type | Null | Key   | Default | Extra |\n+-----------+---------------+-------+------+------+-------+---------+-------+\n| tableA    | DUP_KEYS      | k1    | INT  | Yes  | true  | NULL    |       |\n|           |               | k2    | INT  | Yes  | true  | NULL    |       |\n|           |               | k3    | INT  | Yes  | true  | NULL    |       |\n|           |               |       |      |      |       |         |       |\n| mv_1      | DUP_KEYS      | k3    | INT  | Yes  | true  | NULL    |       |\n|           |               | k2    | INT  | Yes  | false | NULL    | NONE  |\n|           |               | k1    | INT  | Yes  | false | NULL    | NONE  |\n+-----------+---------------+-------+------+------+-------+---------+-------+\n"))),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Query matching"),(0,r.yg)("p",{parentName:"li"},"At this time, if the user's query has k3 column, the filter condition is, for example:"),(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre"},"select k1, k2, k3 from table A where k3=1;\n")),(0,r.yg)("p",{parentName:"li"},"At this time, the query will read data directly from the mv_1 materialized view just created. The materialized view has a prefix index on k3, and query efficiency will also be improved."))),(0,r.yg)("h2",{id:"best-practice-4"},"Best Practice 4"),(0,r.yg)("admonition",{title:"Tips",type:"tip"},(0,r.yg)("p",{parentName:"admonition"},"This feature is supported since the Apache Doris 2.0 version")),(0,r.yg)("p",null,"In ",(0,r.yg)("inlineCode",{parentName:"p"},"Doris 2.0"),", we have made some enhancements to the expressions supported by the materialized view. This example will mainly reflect the support and early filtering of the new version of the materialized view for various expressions."),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Create a base table and insert some data."),(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"create table d_table (\n   k1 int null,\n   k2 int not null,\n   k3 bigint null,\n   k4 date null\n)\nduplicate key (k1,k2,k3)\ndistributed BY hash(k1) buckets 3\nproperties(\"replication_num\" = \"1\");\n\ninsert into d_table select 1,1,1,'2020-02-20';\ninsert into d_table select 2,2,2,'2021-02-20';\ninsert into d_table select 3,-3,null,'2022-02-20';\n"))),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Create some materialized views."),(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"create materialized view k1a2p2ap3ps as select abs(k1)+k2+1,sum(abs(k2+2)+k3+3) from d_table group by abs(k1)+k2+1;\ncreate materialized view kymd as select year(k4),month(k4) from d_table where year(k4) = 2020; // Filter with where expression in advance to reduce the amount of data in the materialized view.\n"))),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Use some queries to test if the materialized view was successfully hit."),(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"select abs(k1)+k2+1, sum(abs(k2+2)+k3+3) from d_table group by abs(k1)+k2+1; // hit k1a2p2ap3ps\nselect bin(abs(k1)+k2+1), sum(abs(k2+2)+k3+3) from d_table group by bin(abs(k1)+k2+1); // hit k1a2p2ap3ps\nselect year(k4),month(k4),day(k4) from d_table; // cannot hit the materialized view because the where condition does not match\nselect year(k4)+month(k4) from d_table where year(k4) = 2020; // hit kymd\n")))),(0,r.yg)("h2",{id:"limitations"},"Limitations"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},"If the condition column of the delete statement exists in the materialized view, the delete operation cannot be performed. If you must delete the data, you need to delete the materialized view before deleting the data."),(0,r.yg)("li",{parentName:"ol"},"Too many materialized views on a single table will affect the efficiency of import: when importing data, the materialized view and Base table data are updated synchronously. If a table has more than 10 materialized views, the import speed may be slow. slow. This is the same as if a single import needs to import 10 table data at the same time."),(0,r.yg)("li",{parentName:"ol"},"For the Unique Key data model, the materialized view can only change the order of the columns and cannot perform aggregation. Therefore, it is not possible to perform coarse-grained aggregation operations on the data by creating a materialized view on the Unique Key model."),(0,r.yg)("li",{parentName:"ol"},"At present, the rewriting behavior of some optimizers to SQL may cause the materialized view to fail to be hit. For example, k1+1-1 is rewritten as k1, between is rewritten as <= and >=, and day is rewritten as dayofmonth. In this case, you need to manually adjust the statements of the query and materialized view.")),(0,r.yg)("h2",{id:"error"},"Error"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},'DATA_QUALITY_ERROR: "The data quality does not satisfy, please check your data"\nMaterialized view creation failed due to data quality issues or Schema Change memory usage exceeding the limit. If it is a memory problem, increase the ',(0,r.yg)("inlineCode",{parentName:"li"},"memory_limitation_per_thread_for_schema_change_bytes")," parameter.\nNote: The bitmap type only supports positive integers. If there are negative Numbers in the original data, the materialized view will fail to be created")),(0,r.yg)("h2",{id:"more-help"},"More Help"),(0,r.yg)("p",null,"For more detailed syntax and best practices for using materialized views, see ",(0,r.yg)("a",{parentName:"p",href:"/docs/2.0/sql-manual/sql-reference/Data-Definition-Statements/Create/CREATE-MATERIALIZED-VIEW"},"CREATE MATERIALIZED VIEW")," and ",(0,r.yg)("a",{parentName:"p",href:"/docs/2.0/sql-manual/sql-reference/Data-Definition-Statements/Drop/DROP-MATERIALIZED-VIEW"},"DROP MATERIALIZED VIEW")," command manual, you can also Enter ",(0,r.yg)("inlineCode",{parentName:"p"},"HELP CREATE MATERIALIZED VIEW")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"HELP DROP MATERIALIZED VIEW")," at the command line of the MySql client for more help information."))}c.isMDXComponent=!0}}]);