"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([[945165],{15680:(e,t,n)=>{n.d(t,{xA:()=>u,yg:()=>y});var a=n(296540);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=p(n),d=i,y=c["".concat(s,".").concat(d)]||c[d]||m[d]||o;return n?a.createElement(y,r(r({ref:t},u),{},{components:n})):a.createElement(y,r({ref:t},u))}));function y(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},677673:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(58168),i=(n(296540),n(15680));const o={title:"Auto Partition",language:"en"},r=void 0,l={unversionedId:"table-design/data-partitioning/auto-partitioning",id:"version-3.0/table-design/data-partitioning/auto-partitioning",title:"Auto Partition",description:"\x3c!--",source:"@site/versioned_docs/version-3.0/table-design/data-partitioning/auto-partitioning.md",sourceDirName:"table-design/data-partitioning",slug:"/table-design/data-partitioning/auto-partitioning",permalink:"/docs/3.0/table-design/data-partitioning/auto-partitioning",draft:!1,tags:[],version:"3.0",frontMatter:{title:"Auto Partition",language:"en"},sidebar:"docs",previous:{title:"Dynamic partitioning",permalink:"/docs/3.0/table-design/data-partitioning/dynamic-partitioning"},next:{title:"Manual bucketing",permalink:"/docs/3.0/table-design/data-partitioning/manual-bucketing"}},s={},p=[{value:"Application scenario",id:"application-scenario",level:2},{value:"Syntax",id:"syntax",level:2},{value:"Sample",id:"sample",level:3},{value:"Constraints",id:"constraints",level:3},{value:"NULL value partition",id:"null-value-partition",level:3},{value:"Example",id:"example",level:2},{value:"Conjunct with Dynamic Partition",id:"conjunct-with-dynamic-partition",level:2},{value:"Best Practice",id:"best-practice",level:3},{value:"Partition Management",id:"partition-management",level:2},{value:"Key points",id:"key-points",level:2},{value:"Keywords",id:"keywords",level:2}],u={toc:p},c="wrapper";function m(e){let{components:t,...n}=e;return(0,i.yg)(c,(0,a.A)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.yg)("h2",{id:"application-scenario"},"Application scenario"),(0,i.yg)("p",null,"The Auto Partition feature supports automatic detection of whether the corresponding partition exists during the data import process. If it does not exist, the partition will be created automatically and imported normally."),(0,i.yg)("p",null,"The auto partition function mainly solves the problem that the user expects to partition the table based on a certain column, but the data distribution of the column is scattered or unpredictable, so it is difficult to accurately create the required partitions when building or adjusting the structure of the table, or the number of partitions is so large that it is too cumbersome to create them manually."),(0,i.yg)("p",null,"Take the time type partition column as an example, in dynamic partitioning, we support the automatic creation of new partitions to accommodate real-time data at specific time periods. For real-time user behavior logs and other scenarios, this feature basically meets the requirements. However, in more complex scenarios, such as dealing with non-real-time data, the partition column is independent of the current system time and contains a large number of discrete values. At this time, to improve efficiency we want to partition the data based on this column, but the data may actually involve the partition can not be grasped in advance, or the expected number of required partitions is too large. In this case, dynamic partitioning or manually created partitions cannot meet our needs, while Auto Partition covers such needs."),(0,i.yg)("p",null,"Suppose the table DDL is as follows:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE `DAILY_TRADE_VALUE`\n(\n    `TRADE_DATE`              datev2 NOT NULL COMMENT 'TRADE_DATE',\n    `TRADE_ID`                varchar(40) NOT NULL COMMENT 'TRADE_ID',\n    ......\n)\nUNIQUE KEY(`TRADE_DATE`, `TRADE_ID`)\nPARTITION BY RANGE(`TRADE_DATE`)\n(\n    PARTITION p_2000 VALUES [('2000-01-01'), ('2001-01-01')),\n    PARTITION p_2001 VALUES [('2001-01-01'), ('2002-01-01')),\n    PARTITION p_2002 VALUES [('2002-01-01'), ('2003-01-01')),\n    PARTITION p_2003 VALUES [('2003-01-01'), ('2004-01-01')),\n    PARTITION p_2004 VALUES [('2004-01-01'), ('2005-01-01')),\n    PARTITION p_2005 VALUES [('2005-01-01'), ('2006-01-01')),\n    PARTITION p_2006 VALUES [('2006-01-01'), ('2007-01-01')),\n    PARTITION p_2007 VALUES [('2007-01-01'), ('2008-01-01')),\n    PARTITION p_2008 VALUES [('2008-01-01'), ('2009-01-01')),\n    PARTITION p_2009 VALUES [('2009-01-01'), ('2010-01-01')),\n    PARTITION p_2010 VALUES [('2010-01-01'), ('2011-01-01')),\n    PARTITION p_2011 VALUES [('2011-01-01'), ('2012-01-01')),\n    PARTITION p_2012 VALUES [('2012-01-01'), ('2013-01-01')),\n    PARTITION p_2013 VALUES [('2013-01-01'), ('2014-01-01')),\n    PARTITION p_2014 VALUES [('2014-01-01'), ('2015-01-01')),\n    PARTITION p_2015 VALUES [('2015-01-01'), ('2016-01-01')),\n    PARTITION p_2016 VALUES [('2016-01-01'), ('2017-01-01')),\n    PARTITION p_2017 VALUES [('2017-01-01'), ('2018-01-01')),\n    PARTITION p_2018 VALUES [('2018-01-01'), ('2019-01-01')),\n    PARTITION p_2019 VALUES [('2019-01-01'), ('2020-01-01')),\n    PARTITION p_2020 VALUES [('2020-01-01'), ('2021-01-01')),\n    PARTITION p_2021 VALUES [('2021-01-01'), ('2022-01-01'))\n)\nDISTRIBUTED BY HASH(`TRADE_DATE`) BUCKETS 10\nPROPERTIES (\n  \"replication_num\" = \"1\"\n);\n")),(0,i.yg)("p",null,"The table stores a large amount of business history data, partitioned based on the date the transaction occurred. As you can see when building the table, we need to manually create the partitions in advance. If the data range of the partitioned columns changes, for example, 2022 is added to the above table, we need to create a partition by ",(0,i.yg)("a",{parentName:"p",href:"../../sql-manual/sql-statements/Data-Definition-Statements/Alter/ALTER-TABLE-PARTITION"},"ALTER-TABLE-PARTITION")," to make changes to the table partition. If such partitions need to be changed, or subdivided at a finer level of granularity, it is very tedious to modify them. At this point we can rewrite the table DDL using Auto Partition."),(0,i.yg)("h2",{id:"syntax"},"Syntax"),(0,i.yg)("p",null,"When creating a table, use the following syntax to populate the ",(0,i.yg)("inlineCode",{parentName:"p"},"partition_info")," section in the ",(0,i.yg)("inlineCode",{parentName:"p"},"CREATE-TABLE")," statement:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"For RANGE Partition:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-sql"},"  AUTO PARTITION BY RANGE (FUNC_CALL_EXPR)\n  ()\n")),(0,i.yg)("p",null,"Where"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-sql"},"  FUNC_CALL_EXPR ::= date_trunc ( <partition_column>, '<interval>' )\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"For LIST Partition:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-sql"},"  AUTO PARTITION BY LIST(`partition_col1`[, `partition_col2`, ...])\n  ()\n")),(0,i.yg)("h3",{id:"sample"},"Sample"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"For Range Partition:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-sql"},"    CREATE TABLE `date_table` (\n        `TIME_STAMP` datev2 NOT NULL COMMENT '\u91c7\u96c6\u65e5\u671f'\n    ) ENGINE=OLAP\n    DUPLICATE KEY(`TIME_STAMP`)\n    AUTO PARTITION BY RANGE (date_trunc(`TIME_STAMP`, 'month'))\n    (\n    )\n    DISTRIBUTED BY HASH(`TIME_STAMP`) BUCKETS 10\n    PROPERTIES (\n    \"replication_allocation\" = \"tag.location.default: 1\"\n    );\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"For List Partition:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-sql"},'  CREATE TABLE `str_table` (\n      `str` varchar not null\n  ) ENGINE=OLAP\n  DUPLICATE KEY(`str`)\n  AUTO PARTITION BY LIST (`str`)\n  (\n  )\n  DISTRIBUTED BY HASH(`str`) BUCKETS 10\n  PROPERTIES (\n  "replication_allocation" = "tag.location.default: 1"\n  );\n')),(0,i.yg)("p",null,"List Auto Partition supports multiple partition columns, which are written in the same way as normal List Partition: ",(0,i.yg)("inlineCode",{parentName:"p"},"AUTO PARTITION BY LIST (`col1`, `col2`, ...)")),(0,i.yg)("h3",{id:"constraints"},"Constraints"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"In auto List Partition, the partition name length ",(0,i.yg)("strong",{parentName:"li"},"must not exceed 50 characters"),". This length is derived from the concatenation and escape of contents of partition columns on corresponding data rows, so the actual allowed length may be shorter."),(0,i.yg)("li",{parentName:"ul"},"In auto Range Partition, the partition function only supports ",(0,i.yg)("inlineCode",{parentName:"li"},"date_trunc"),", and the partition column supports only ",(0,i.yg)("inlineCode",{parentName:"li"},"DATE")," or ",(0,i.yg)("inlineCode",{parentName:"li"},"DATETIME")," types. "),(0,i.yg)("li",{parentName:"ul"},"In auto List Partition, function calls are not supported, and the partition column supports ",(0,i.yg)("inlineCode",{parentName:"li"},"BOOLEAN"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"TINYINT"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"SMALLINT"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"INT"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"BIGINT"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"LARGEINT"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"DATE"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"DATETIME"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"CHAR"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"VARCHAR")," data types, with partition values being enumeration values. "),(0,i.yg)("li",{parentName:"ul"},"In auto List Partition, for every existing value in the partition column that does not correspond to a partition, a new independent partition will be created. ")),(0,i.yg)("h3",{id:"null-value-partition"},"NULL value partition"),(0,i.yg)("p",null,"When the session variable ",(0,i.yg)("inlineCode",{parentName:"p"},"allow_partition_column_nullable")," is enabled:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"For Auto List Partition, the corresponding NULL value partition will be created automatically:")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-sql"},'mysql> create table auto_null_list(\n    -> k0 varchar null\n    -> )\n    -> auto partition by list (k0)\n    -> (\n    -> )\n    -> DISTRIBUTED BY HASH(`k0`) BUCKETS 1\n    -> properties("replication_num" = "1");\nQuery OK, 0 rows affected (0.10 sec)\n\nmysql> insert into auto_null_list values (null);\nQuery OK, 1 row affected (0.28 sec)\n\nmysql> select * from auto_null_list;\n+------+\n| k0   |\n+------+\n| NULL |\n+------+\n1 row in set (0.20 sec)\n\nmysql> select * from auto_null_list partition(pX);\n+------+\n| k0   |\n+------+\n| NULL |\n+------+\n1 row in set (0.20 sec)\n')),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"For Auto Range Partition, ",(0,i.yg)("strong",{parentName:"li"},"null columns are not supported to be partition columns"),".")),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-sql"},'mysql>  CREATE TABLE `range_table_nullable` (\n    ->      `k1` INT,\n    ->      `k2` DATETIMEV2(3),\n    ->      `k3` DATETIMEV2(6)\n    ->  ) ENGINE=OLAP\n    ->  DUPLICATE KEY(`k1`)\n    ->  AUTO PARTITION BY RANGE (date_trunc(`k2`, \'day\'))\n    ->  (\n    ->  )\n    ->  DISTRIBUTED BY HASH(`k1`) BUCKETS 16\n    ->  PROPERTIES (\n    ->  "replication_allocation" = "tag.location.default: 1"\n    ->  );\nERROR 1105 (HY000): errCode = 2, detailMessage = AUTO RANGE PARTITION doesn\'t support NULL column\n')),(0,i.yg)("h2",{id:"example"},"Example"),(0,i.yg)("p",null,"When using Auto Partition, the example in the Application scenarios section can be rewritten as:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE `DAILY_TRADE_VALUE`\n(\n    `TRADE_DATE`              datev2 NOT NULL COMMENT '\u4ea4\u6613\u65e5\u671f',\n    `TRADE_ID`                varchar(40) NOT NULL COMMENT '\u4ea4\u6613\u7f16\u53f7',\n    ......\n)\nUNIQUE KEY(`TRADE_DATE`, `TRADE_ID`)\nAUTO PARTITION BY RANGE (date_trunc(`TRADE_DATE`, 'year'))\n(\n)\nDISTRIBUTED BY HASH(`TRADE_DATE`) BUCKETS 10\nPROPERTIES (\n  \"replication_num\" = \"1\"\n);\n")),(0,i.yg)("p",null,"Take the example of a table with only two columns, at which point the new table has no default partitions:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-sql"},"mysql> show partitions from `DAILY_TRADE_VALUE`;\nEmpty set (0.12 sec)\n")),(0,i.yg)("p",null,"After inserting data and checking again, it is found that the table has created the corresponding partitions:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-sql"},"mysql> insert into `DAILY_TRADE_VALUE` values ('2012-12-13', 1), ('2008-02-03', 2), ('2014-11-11', 3);\nQuery OK, 3 rows affected (0.88 sec)\n\nmysql> show partitions from `DAILY_TRADE_VALUE`;\n+-------------+-----------------+----------------+---------------------+--------+--------------+--------------------------------------------------------------------------------+-----------------+---------+----------------+---------------+---------------------+---------------------+--------------------------+----------+------------+-------------------------+-----------+\n| PartitionId | PartitionName   | VisibleVersion | VisibleVersionTime  | State  | PartitionKey | Range                                                                          | DistributionKey | Buckets | ReplicationNum | StorageMedium | CooldownTime        | RemoteStoragePolicy | LastConsistencyCheckTime | DataSize | IsInMemory | ReplicaAllocation       | IsMutable |\n+-------------+-----------------+----------------+---------------------+--------+--------------+--------------------------------------------------------------------------------+-----------------+---------+----------------+---------------+---------------------+---------------------+--------------------------+----------+------------+-------------------------+-----------+\n| 180060      | p20080101000000 | 2              | 2023-09-18 21:49:29 | NORMAL | TRADE_DATE   | [types: [DATEV2]; keys: [2008-01-01]; ..types: [DATEV2]; keys: [2009-01-01]; ) | TRADE_DATE      | 10      | 1              | HDD           | 9999-12-31 23:59:59 |                     | NULL                     | 0.000    | false      | tag.location.default: 1 | true      |\n| 180039      | p20120101000000 | 2              | 2023-09-18 21:49:29 | NORMAL | TRADE_DATE   | [types: [DATEV2]; keys: [2012-01-01]; ..types: [DATEV2]; keys: [2013-01-01]; ) | TRADE_DATE      | 10      | 1              | HDD           | 9999-12-31 23:59:59 |                     | NULL                     | 0.000    | false      | tag.location.default: 1 | true      |\n| 180018      | p20140101000000 | 2              | 2023-09-18 21:49:29 | NORMAL | TRADE_DATE   | [types: [DATEV2]; keys: [2014-01-01]; ..types: [DATEV2]; keys: [2015-01-01]; ) | TRADE_DATE      | 10      | 1              | HDD           | 9999-12-31 23:59:59 |                     | NULL                     | 0.000    | false      | tag.location.default: 1 | true      |\n+-------------+-----------------+----------------+---------------------+--------+--------------+--------------------------------------------------------------------------------+-----------------+---------+----------------+---------------+---------------------+---------------------+--------------------------+----------+------------+-------------------------+-----------+\n3 rows in set (0.12 sec)\n")),(0,i.yg)("p",null,"It can be concluded that the partitions created by Auto Partition share the same functionality as partitions created by manual partitioning."),(0,i.yg)("h2",{id:"conjunct-with-dynamic-partition"},"Conjunct with Dynamic Partition"),(0,i.yg)("p",null,"Since 3.0.3, Doris supports both Auto and Dynamic Partition. In this case, both functions are in effect:"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"Auto Partition will automatically create partitions on demand during data import;"),(0,i.yg)("li",{parentName:"ol"},"Dynamic Partition will automatically create, recycle and dump partitions.")),(0,i.yg)("p",null,"There is no conflict between the two syntaxes, just set the corresponding clauses/attributes at the same time."),(0,i.yg)("h3",{id:"best-practice"},"Best Practice"),(0,i.yg)("p",null,"In scenarios where you need to set a limit on the partition lifecycle, you can ",(0,i.yg)("strong",{parentName:"p"},"disable the creation of Dynamic Partition, leaving the creation of partitions to be completed by Auto Partition"),", and complete the management of the partition lifecycle through the Dynamic Partition's function of dynamically reclaiming partitions:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-sql"},'create table auto_dynamic(\n    k0 datetime(6) NOT NULL\n)\nauto partition by range (date_trunc(k0, \'year\'))\n(\n)\nDISTRIBUTED BY HASH(`k0`) BUCKETS 2\nproperties(\n    "dynamic_partition.enable" = "true",\n    "dynamic_partition.prefix" = "p",\n    "dynamic_partition.start" = "-50",\n    "dynamic_partition.end" = "0", --- Dynamic Partition No Partition Creation\n    "dynamic_partition.time_unit" = "year",\n    "replication_num" = "1"\n);\n')),(0,i.yg)("p",null,"This way we have both the flexibility of Auto Partition and consistency in partition names."),(0,i.yg)("admonition",{type:"note"},(0,i.yg)("p",{parentName:"admonition"},"In some early versions prior to 2.1.7, this feature was not disabled but not recommended.")),(0,i.yg)("h2",{id:"partition-management"},"Partition Management"),(0,i.yg)("admonition",{type:"tip"},(0,i.yg)("p",{parentName:"admonition"},"Since 2.1.6, Doris supports the ",(0,i.yg)("inlineCode",{parentName:"p"},"partitions")," table function and the ",(0,i.yg)("inlineCode",{parentName:"p"},"auto_partition_name")," function, which can be used to easily find and manage partitions for data.")),(0,i.yg)("p",null,"When Auto Partition is enabled, partition names can be mapped to partitions using the ",(0,i.yg)("inlineCode",{parentName:"p"},"auto_partition_name")," function.The ",(0,i.yg)("inlineCode",{parentName:"p"},"partitions")," table function generates detailed partition information from partition names. Let's take the ",(0,i.yg)("inlineCode",{parentName:"p"},"DAILY_TRADE_VALUE")," table as an example to see its current partition after we insert data:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-sql"},'mysql> select * from partitions("catalog"="internal","database"="optest","table"="DAILY_TRADE_VALUE") where PartitionName = auto_partition_name(\'range\', \'year\', \'2008-02-03\');\n+-------------+-----------------+----------------+---------------------+--------+--------------+--------------------------------------------------------------------------------+-----------------+---------+----------------+---------------+---------------------+---------------------+--------------------------+-----------+------------+-------------------------+-----------+--------------------+--------------+\n| PartitionId | PartitionName   | VisibleVersion | VisibleVersionTime  | State  | PartitionKey | Range                                                                          | DistributionKey | Buckets | ReplicationNum | StorageMedium | CooldownTime        | RemoteStoragePolicy | LastConsistencyCheckTime | DataSize  | IsInMemory | ReplicaAllocation       | IsMutable | SyncWithBaseTables | UnsyncTables |\n+-------------+-----------------+----------------+---------------------+--------+--------------+--------------------------------------------------------------------------------+-----------------+---------+----------------+---------------+---------------------+---------------------+--------------------------+-----------+------------+-------------------------+-----------+--------------------+--------------+\n|      127095 | p20080101000000 |              2 | 2024-11-14 17:29:02 | NORMAL | TRADE_DATE   | [types: [DATEV2]; keys: [2008-01-01]; ..types: [DATEV2]; keys: [2009-01-01]; ) | TRADE_DATE      |      10 |              1 | HDD           | 9999-12-31 23:59:59 |                     | \\N                       | 985.000 B |          0 | tag.location.default: 1 |         1 |                  1 | \\N           |\n+-------------+-----------------+----------------+---------------------+--------+--------------+--------------------------------------------------------------------------------+-----------------+---------+----------------+---------------+---------------------+---------------------+--------------------------+-----------+------------+-------------------------+-----------+--------------------+--------------+\n1 row in set (0.18 sec)\n')),(0,i.yg)("p",null,"In this way the IDs and values of each partition can be precisely filtered for subsequent partition-specific operations (e.g. ",(0,i.yg)("inlineCode",{parentName:"p"},"insert overwrite partition"),"). "),(0,i.yg)("p",null,"For a detailed grammar description, see: ",(0,i.yg)("a",{parentName:"p",href:"../../sql-manual/sql-functions/string-functions/auto-partition-name"},"auto_partition_name"),"\uff0c",(0,i.yg)("a",{parentName:"p",href:"../../sql-manual/sql-functions/table-valued-functions/partitions"},"partitions"),"\u3002"),(0,i.yg)("h2",{id:"key-points"},"Key points"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Similar to regular partitioned tables, aoto List Partition supports multi-column partitioning with no syntax differences. "),(0,i.yg)("li",{parentName:"ul"},"If partitions are created during data insertion or import processes, and the entire import process is not completed (fails or is canceled), the created partitions will not be automatically deleted. "),(0,i.yg)("li",{parentName:"ul"},"Tables using Auto Partition only differ in the method of partition creation, switching from manual to automatic. The original usage of the table and its created partitions remains the same as non-Auto Partition tables or partitions. "),(0,i.yg)("li",{parentName:"ul"},"To prevent the accidental creation of too many partitions, Apache Doris controls the maximum number of partitions an Auto Partition table can accommodate through the ",(0,i.yg)("inlineCode",{parentName:"li"},"max_auto_partition_num setting")," in the FE configuration. This value can be adjusted if needed."),(0,i.yg)("li",{parentName:"ul"},"When importing data into a table with Auto Partition enabled, the coordinator sends data with a polling interval different from regular tables. Refer to ",(0,i.yg)("inlineCode",{parentName:"li"},"olap_table_sink_send_interval_auto_partition_factor"),"  in ",(0,i.yg)("a",{parentName:"li",href:"../../admin-manual/config/be-config"},"BE Configuration")," for details. This setting does not have an impact after ",(0,i.yg)("inlineCode",{parentName:"li"},"enable_memtable_on_sink_node")," is enabled. "),(0,i.yg)("li",{parentName:"ul"},"When use ",(0,i.yg)("a",{parentName:"li",href:"../../sql-manual/sql-statements/Data-Manipulation-Statements/Manipulation/INSERT-OVERWRITE"},"insert-overwrite")," to load data into Auto Partition table, the behaviour is detailed in the INSERT OVERWRITE documentation."),(0,i.yg)("li",{parentName:"ul"},"If metadata operations are involved when importing and creating partitions, the import process may fail.")),(0,i.yg)("h2",{id:"keywords"},"Keywords"),(0,i.yg)("p",null,"AUTO, PARTITION, AUTO_PARTITION"))}m.isMDXComponent=!0}}]);